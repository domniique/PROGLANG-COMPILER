package humanlang;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * LexicalAnalyzer - Tokenizes and validates HumanLang source code
 * 
 * This class is responsible for:
 * - Breaking down source code into individual tokens
 * - Validating token syntax and structure
 * - Ensuring keywords are properly capitalized
 * - Detecting syntax errors before execution
 */
final class LexicalAnalyzer {
    // Reserved keywords in HumanLang (must be uppercase)
    public final String [] KEYWORDS = {
        "NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY", "SHOW", "ASK", "AND", "OR", "NOT", "IF", "ELSE", "THEN", "WHILE", "CONTINUE", "BREAK", "RETURN", "EQUAL", "NOT EQUAL", "TRUE", "FALSE", "SELECT", "WHEN", "DEFAULT", "TASK", "DO", "with"
    };
    
    // Valid punctuation characters
    public final String PUNCTUATIONS = ",()=:{}[];";
    
    // Valid operator characters
    public final String OPERATORS = "=+-*/%<>!&|";
    
    // List of tokens extracted from source code
    public ArrayList<String> tokens;
    
    // Original source code string
    public String code;
    
    /**
     * Constructor - Initializes the lexical analyzer with source code
     * @param code The HumanLang source code to analyze
     */
    public LexicalAnalyzer(String code){
        this.code = removeComments(code);
        this.tokens = new ArrayList<>();
        tokenize();
    }                                                                                                                               
    
    /**
     * Constructor - Initializes the lexical analyzer with source code and line number tracking
     * @param code The HumanLang source code to analyze
     * @param lineNumber The line number for error reporting
     */
    public LexicalAnalyzer(String code, int lineNumber){
        this.lineNumber = lineNumber;
        this.code = removeComments(code);
        this.tokens = new ArrayList<>();
        tokenize();
    }
    
    private int lineNumber = 0;                                                                                                                               
    
    /**
     * Removes comments from the source code
     * Comments are enclosed between # symbols: # comment #
     * Works for both single-line and multi-line comments
     * @param code The source code with comments
     * @return The source code with comments removed
     */
    private String removeComments(String code) {
        StringBuilder result = new StringBuilder();
        boolean inString = false;
        char stringDelimiter = '\0';
        boolean inComment = false;
        int commentStartLine = 1;
        int currentLine = 1;
        
        for (int i = 0; i < code.length(); i++) {
            char currentChar = code.charAt(i);
            
            // Track line numbers
            if (currentChar == '\n') {
                currentLine++;
            }
            
            // Handle string literals - don't process # inside strings
            if ((currentChar == '"' || currentChar == '\'') && (i == 0 || code.charAt(i - 1) != '\\')) {
                if (inString && currentChar == stringDelimiter) {
                    // Closing quote
                    inString = false;
                    stringDelimiter = '\0';
                    if (!inComment) {
                        result.append(currentChar);
                    }
                } else if (!inString && !inComment) {
                    // Opening quote
                    inString = true;
                    stringDelimiter = currentChar;
                    result.append(currentChar);
                } else if (!inComment) {
                    // Quote inside string (different type)
                    result.append(currentChar);
                }
            }
            // Handle comments - # marks both start and end, but only when used as comment delimiter
            else if (currentChar == '#' && !inString) {
                // Check if this # is being used as a comment delimiter
                // A # is a comment delimiter if:
                // - It's at the start of the code, OR
                // - It's preceded by whitespace/newline, OR
                // - It's followed by whitespace/newline/end-of-file (closing delimiter)
                boolean isCommentDelimiter = false;
                
                if (i == 0) {
                    // First character of the code
                    isCommentDelimiter = true;
                } else {
                    // Check if previous character is whitespace or newline
                    char prevChar = code.charAt(i - 1);
                    if (prevChar == ' ' || prevChar == '\t' || prevChar == '\n' || prevChar == '\r') {
                        isCommentDelimiter = true;
                    }
                }
                
                // Also check if this # is followed by whitespace/newline/end (for closing comments)
                if (!isCommentDelimiter) {
                    if (i == code.length() - 1) {
                        // Last character of the code
                        isCommentDelimiter = true;
                    } else {
                        char nextChar = code.charAt(i + 1);
                        if (nextChar == ' ' || nextChar == '\t' || nextChar == '\n' || nextChar == '\r') {
                            isCommentDelimiter = true;
                        }
                    }
                }
                
                if (isCommentDelimiter) {
                if (inComment) {
                    // Closing # - end the comment
                    inComment = false;
                } else {
                    // Opening # - start the comment
                    inComment = true;
                        commentStartLine = currentLine;
                    }
                } else {
                    // This # is part of code (like in variable names), not a comment delimiter
                    if (!inComment) {
                        result.append(currentChar);
                    }
                }
            }
            // Regular character - add if not in comment
            else if (!inComment) {
                result.append(currentChar);
            }
        }
        
        // Check for unclosed comment
        if (inComment) {
            if (commentStartLine > 0) {
                System.out.println("Line " + commentStartLine + ": Error: Unclosed comment detected. Comments must end with #");
            } else {
            System.out.println("Error: Unclosed comment detected. Comments must end with #");
            }
            System.exit(0);
        }
        
        return result.toString();
    }                                                                                                                               
    
    /**
     * Returns the code with comments removed (for multiline comment handling)
     * @return The source code with comments removed
     */
    public String getCodeWithoutComments() {
        return this.code;
    }
    
    /**
     * Tokenizes the source code into individual tokens
     * Handles strings, operators, punctuation, and identifiers
     */
    public void tokenize(){
        StringBuilder token = new StringBuilder();
        boolean isStringMark = false; // Track if we're inside a string literal
        char stringDelimiter = '\0'; // Track which quote character started the string
        
        // Process each character in the source code
        for (int i=0; i<code.length(); i++){
            char currentChar = code.charAt(i);
            
            // Handle string and character literals (quotes)
            if ((currentChar == '"' || currentChar == '\'') && (i == 0 || code.charAt(i - 1) != '\\')) {
                if (isStringMark && currentChar == stringDelimiter) {
                    // Closing quote - finalize the string token (must match opening quote)
                    token.append(currentChar);
                    tokens.add(token.toString());
                    token.setLength(0);
                    isStringMark = false;
                    stringDelimiter = '\0';
                } else if (!isStringMark) {
                    // Starting new string literal
                    if (token.length() > 0) {
                        tokens.add(token.toString());
                        token.setLength(0);
                    }
                    token.append(currentChar);
                    isStringMark = true;
                    stringDelimiter = currentChar; // Remember which quote started this string
                } else {
                    // Inside string literal but different quote type - treat as regular character
                    token.append(currentChar);
                }
            }  else if (isStringMark){
                // Inside string literal - add character to token
                token.append(currentChar);
            } else if (PUNCTUATIONS.indexOf(currentChar) != -1 || OPERATORS.indexOf(currentChar) != -1){
                // Found punctuation or operator - finalize current token and add operator
                 if (token.length() > 0) {
                    tokens.add(token.toString());
                    token.setLength(0);
                }
                tokens.add(String.valueOf(currentChar));
            } else if (Character.isWhitespace(currentChar)) {
                // Whitespace - finalize current token if exists
                if (token.length() > 0) {
                    tokens.add(token.toString());
                    token.setLength(0);
                }
            } else {
                // Regular character - add to current token
                token.append(currentChar);
            }
    }
        // Check for unclosed string literals
        if (isStringMark) {
            if (lineNumber > 0) {
                System.out.println("Line " + lineNumber + ": Error: Unclosed string or character literal detected.");
            } else {
            System.out.println("Error: Unclosed string or character literal detected.");
            }
            System.exit(0);
        }
        
        // Add final token if exists
        if (token.length()>0){
            tokens.add(token.toString());
        }
    }
    
    /**
     * Analyzes tokens for syntax validity
     * Validates keywords, literals, operators, and identifiers
     * @return true if all tokens are valid, false otherwise
     */
    public boolean analyze() {
        // Validate each token
        for (String token : tokens) {
            token = token.trim();
            if (token.isEmpty()) continue;

            // Check for incorrect keyword capitalization - reject any case variation
            for (String keyword : KEYWORDS) {
                if (token.equalsIgnoreCase(keyword) && !token.equals(keyword)) {
                    if (lineNumber > 0) {
                        System.out.println("Line " + lineNumber + ": Error: '" + token + "' appears to be a keyword. Keywords cannot be used as variable names (even in lowercase). Did you mean to use the keyword '" + keyword + "'?");
                    } else {
                    System.out.println("Error: '" + token + "' appears to be a keyword. Keywords cannot be used as variable names (even in lowercase). Did you mean to use the keyword '" + keyword + "'?");
                    }
                    System.exit(0);
                }
            }

            // Validate token type - must be one of the recognized types
            if (!(isKeyword(token) ||
                  isIntegerLiteral(token) ||
                  isDoubleLiteral(token) ||
                  isOperator(token) ||
                  isBoolean(token) ||
                  isStringLiteral(token) ||
                  isCharLiteral(token) ||
                  isIdentifier(token) ||
                  isPunctuation(token))) {

                if (lineNumber > 0) {
                    System.out.println("Line " + lineNumber + ": Unrecognized token: [" + token + "]");
                } else {
                System.out.println("Unrecognized token: [" + token + "]");
                }
                System.exit(0);
            }
        }
        return true;
    }

    /**
     * Validates that each line ends with a semicolon (except control structures)
     * @param code The source code to validate
     * @return true if all lines properly end with semicolons
     */
    public boolean validateSemicolons(String code) {
        String[] lines = code.split("\n");
        
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i].trim();
            
            // Skip empty lines
            if (line.isEmpty()) continue;
            
            // Skip lines that are just closing braces
            if (line.equals("}")) continue;
            
            // Skip lines that start with closing braces (for multiline statements)
            if (line.startsWith("}")) continue;
            
            // Skip control structures that use braces (don't need semicolons)
            if (line.startsWith("WHILE ") && line.contains("THEN {")) continue;
            if (line.startsWith("IF ") && line.contains("THEN {")) continue;
            if (line.startsWith("ELSE IF ") && line.contains("THEN {")) continue;
            if (line.startsWith("ELSE ") && line.contains("THEN {")) continue;
            if (line.startsWith("SELECT") && line.contains("THEN {")) continue;
            if (line.startsWith("WHEN ")) continue;
            if (line.startsWith("DEFAULT")) continue;
            if (line.startsWith("TASK") && line.contains("DO {")) continue;
            if (line.split(" ").length > 1 && Arrays.asList("NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY").contains(line.split(" ")[0]) && line.split(" ")[1].equals("TASK") && line.contains("DO {")) continue;
            
            // Check if line ends with semicolon
            if (!line.endsWith(";")) {
                System.out.println("Error: Line " + (i + 1) + " must end with a semicolon: " + line);
                System.exit(0);
            }
        }
        return true;
    }

    
    /**
     * Checks if token is a punctuation character
     * @param token The token to check
     * @return true if token is punctuation
     */
    public boolean isPunctuation(String token){
        return token.length() == 1 && PUNCTUATIONS.indexOf(token.charAt(0)) != -1;
    }
    
    /**
     * Checks if token is a reserved keyword
     * @param token The token to check
     * @return true if token is a keyword
     */
    public boolean isKeyword(String token){
        for (String keyword: KEYWORDS){
            if(token.equals(keyword)){
                return true;
            }
        }
        return false;
    }
    
    /**
     * Checks if token is an integer literal (positive or negative)
     * @param token The token to check
     * @return true if token is an integer
     */
    public boolean isIntegerLiteral(String token){
        return Pattern.matches("^-?\\d+$", token);
    }
    
    /**
     * Checks if token is a decimal literal (positive or negative)
     * @param token The token to check
     * @return true if token is a decimal number
     */
    public boolean isDoubleLiteral(String token){
        return Pattern.matches("^-?\\d+\\.\\d+$", token);
    }
    
    /**
     * Checks if token is a boolean literal (true/false)
     * @param token The token to check
     * @return true if token is a boolean
     */
     public boolean isBoolean(String token) {
        return token.equals("true") || token.equals("false");
    }

    /**
     * Checks if token is a string literal (enclosed in double quotes)
     * @param token The token to check
     * @return true if token is a string literal
     */
    public boolean isStringLiteral(String token) {
        return token.startsWith("\"") && token.endsWith("\"");
    }

    /**
     * Checks if token is a character literal (single character in single quotes)
     * @param token The token to check
     * @return true if token is a character literal
     */
    public boolean isCharLiteral(String token) {
        return token.length() == 3 && token.startsWith("'") && token.endsWith("'");
    }

    /**
     * Validates variable name according to HumanLang syntax rules:
     * - Only alphanumeric characters and underscores allowed
     * - No keywords
     * - Starts with letters or underscore (must be followed by alphanumeric character)
     * - No special symbols (@, #, $, %, &, or spaces)
     * @param varName The variable name to validate
     * @return true if the variable name is valid according to syntax rules
     */
    public boolean validateVariableName(String varName) {
        // Check for empty or null
        if (varName == null || varName.trim().isEmpty()) {
            return false;
        }
        
        // Check for spaces
        if (varName.contains(" ")) {
            return false;
        }
        
        // Check for special symbols (@, #, $, %, &)
        if (varName.matches(".*[@#$%&].*")) {
            return false;
        }
        
        // Must start with letter or underscore
        if (!varName.matches("^[a-zA-Z_].*")) {
            return false;
        }
        
        // If starts with underscore, must be followed by at least one alphanumeric character
        if (varName.startsWith("_") && varName.length() > 1) {
            if (!varName.matches("^_[a-zA-Z0-9]+$")) {
                return false;
            }
        }
        
        // Underscore alone is not allowed
        if (varName.equals("_")) {
            return false;
        }
        
        // Only alphanumeric characters and underscores allowed
        if (!varName.matches("^[a-zA-Z0-9_]+$")) {
            return false;
        }
        
        // Check if it's a keyword (case-insensitive)
        String[] keywords = {"NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY", "SHOW", "ASK", 
                           "AND", "OR", "NOT", "IF", "ELSE", "THEN", "WHILE", "CONTINUE", 
                           "BREAK", "RETURN", "TRUE", "FALSE"};
        for (String keyword : keywords) {
            if (varName.equalsIgnoreCase(keyword)) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * Checks if token is a valid identifier (variable name)
     * @param token The token to check
     * @return true if token is a valid identifier
     */
    public boolean isIdentifier(String token) {
        return validateVariableName(token);
    }
    
    /**
     * Checks if token is a valid operator
     * @param token The token to check
     * @return true if token is an operator
     */
    public boolean isOperator(String token) {
        return token.matches("==|!=|<=|>=|<|>|=|\\+|\\-|\\*|/|%|AND|OR|NOT");
    }
}

/**
 * Represents a parameter in a function definition.
 */
class Parameter {
    String type;
    String name;

    public Parameter(String type, String name) {
        this.type = type;
        this.name = name;
    }
}

/**
 * Represents a user-defined function (TASK).
 */
class FunctionDefinition {
    String name;
    String returnType; // null for void functions
    List<Parameter> parameters = new ArrayList<>();
    String body;
    int startLine;
}


/**
 * Interpreter - Executes HumanLang source code
 * 
 * This class is responsible for:
 * - Executing HumanLang statements and expressions
 * - Managing variable storage and scope
 * - Handling control flow (IF/ELSE, WHILE loops)
 * - Processing user input and output
 * - Evaluating arithmetic and boolean expressions
 */
final class Interpreter {
    // Variable storage - maps variable names to their values
    private Map<String, Object> variables = new HashMap<>();
    // Function storage
    private static Map<String, FunctionDefinition> functions = new HashMap<>();
    
    // Return value handling
    private Object returnValue = null;
    private boolean returnFlag = false;
    
    // Loop control flags
    private boolean inLoop = false; // Track if we're inside a loop
    private boolean breakFlag = false; // Signal to break out of loop
    private boolean continueFlag = false; // Signal to continue loop iteration

    // Scanner for user input
    private Scanner scanner = new Scanner(System.in);
    
    // Reserved keywords that cannot be used as variable names
    private static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
        "NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY", "SHOW", "ASK", "AND", "OR", "NOT", "IF", "ELSE", "THEN", "WHILE", "CONTINUE", "BREAK", "RETURN", "EQUAL", "NOT EQUAL", "TRUE", "FALSE", "SELECT", "WHEN", "DEFAULT", "TASK", "DO", "with"
    ));
    
    private static final Set<String> DATA_TYPES = new HashSet<>(Arrays.asList(
        "NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY"
    ));
    
    /**
     * Checks if a variable name is a reserved keyword (case-insensitive)
     * @param varName The variable name to check
     * @return true if the name is a reserved keyword
     */
    private static boolean isReservedKeyword(String varName) {
        return KEYWORDS.contains(varName.toUpperCase());
    }

    
    /**
     * Checks if a variable name is a data type keyword (case-insensitive)
     * @param varName The variable name to check
     * @return true if the name is a data type keyword
     */
    private static boolean isDataTypeKeyword(String varName) {
        return DATA_TYPES.contains(varName.toUpperCase());
    }

    /**
     * Main execution method - reads and executes HumanLang source code
     * @param filePath Path to the HumanLang source file
     */
    public void execute(String filePath) {
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;
            int lineNumber = 0;
            boolean skipElse = false; // Track if an IF/ELSE IF condition was already executed
            boolean inIfChain = false; // Track if we're in an IF-ELSE chain
            // Process each line of the source code
            while ((line = br.readLine()) != null) {
                lineNumber++;
                line = line.trim();
                
                // Validate line contains only allowed characters (including @() for variable interpolation, # for comments, and \\ for escape sequences)
                if (!line.isEmpty() && !line.matches("[a-zA-Z0-9_\\s\"'()+\\-*/%=<>!.,:{}\\[\\];@$#\\\\]*")) {
                    terminate(lineNumber, "Error: Invalid or unnecessary character found → " + line);
                }
                
                // Explicitly reject // comments - HumanLang only supports # comments
                if (line.contains("//")) {
                    terminate(lineNumber, "Error: '//' comments are not allowed. Use # comment # syntax instead → " + line);
                }
                
                // Handle IF statements
                if (line.startsWith("IF")) {
                    inIfChain = true;
                    if (!line.contains("THEN")) {
                        terminate(lineNumber, "Error: Missing THEN in IF statement → " + line);
                    }
                    if (!line.contains("{")) {
                        terminate(lineNumber, "Error: Missing '{' after THEN in IF statement → " + line);
                    }

                    String condition = extractCondition(line);
                    boolean conditionTrue = evaluateBooleanExpression(condition, variables);

                    StringBuilder block = new StringBuilder();
                    int braceCount = 1; // We already have one opening brace from IF THEN {
                    String closingLine = null; // Store the line that closes the block
                    while ((line = br.readLine()) != null && braceCount > 0) {
                        String trimmedLine = line.trim();
                        // Check for closing brace first
                        if (trimmedLine.contains("}")) {
                            braceCount--;
                            closingLine = trimmedLine; // Remember the closing line
                        }
                        if (braceCount > 0 && trimmedLine.contains("{")) braceCount++;
                        if (braceCount > 0) {
                        block.append(line).append("\n");
                        }
                    }

                    if (conditionTrue) {
                        executeBlock(block.toString(), variables);
                        skipElse = true;   // ✅ mark chain as already executed
                    } else {
                        skipElse = false;  // ✅ still open to ELSE IF / ELSE
                    }
                    
                    // Check if the closing line contains ELSE IF or ELSE on the same line
                    if (closingLine != null && (closingLine.startsWith("}ELSE") || closingLine.startsWith("} ELSE"))) {
                        // Process it as the next line
                        line = closingLine;
                        lineNumber++; // Increment line number since we're processing this line now
                        // Don't continue - let the code fall through to process ELSE IF/ELSE
                    } else {
                    continue;
                    }
                }

                else if (line.startsWith("ELSE IF")) {
                    if (!inIfChain) {
                        terminate(lineNumber, "Error: 'ELSE IF' without preceding IF.");
                    }
                    if (!line.contains("THEN")) {
                        terminate(lineNumber, "Error: Missing THEN in ELSE IF statement → " + line);
                    }
                    if (!line.contains("{")) {
                        terminate(lineNumber, "Error: Missing '{' after THEN in ELSE IF statement → " + line);
                    }

                    // ✅ If an earlier IF or ELSE IF already ran → skip this block entirely
                    if (skipElse) {
                        skipBlock(br);
                        continue;
                    }

                    String condition = extractCondition(line);
                    boolean conditionTrue = evaluateBooleanExpression(condition, variables);

                    StringBuilder block = new StringBuilder();
                    int braceCount = 1; // We already have one opening brace from ELSE IF THEN {
                    String closingLine = null; // Store the line that closes the block
                    while ((line = br.readLine()) != null && braceCount > 0) {
                        String trimmedLine = line.trim();
                        // Check for closing brace first
                        if (trimmedLine.contains("}")) {
                            braceCount--;
                            closingLine = trimmedLine; // Remember the closing line
                        }
                        if (braceCount > 0 && trimmedLine.contains("{")) braceCount++;
                        if (braceCount > 0) {
                        block.append(line).append("\n");
                        }
                    }

                    if (conditionTrue) {
                        executeBlock(block.toString(), variables);
                        skipElse = true; // ✅ mark this chain as done
                    }
                    
                    // Check if the closing line contains ELSE IF or ELSE on the same line
                    if (closingLine != null && (closingLine.startsWith("}ELSE") || closingLine.startsWith("} ELSE"))) {
                        // Process it as the next line
                        line = closingLine;
                        lineNumber++; // Increment line number since we're processing this line now
                        // Don't continue - let the code fall through to process ELSE IF/ELSE
                    } else {
                    continue;
                    }
                }

                else if (line.startsWith("ELSE")) {
                    
                    if (!inIfChain) {
                        terminate(lineNumber, "Error: 'ELSE' without preceding IF.");
                    }
                    if (!line.contains("THEN")) {
                        terminate(lineNumber, "Error: Missing THEN in ELSE statement → " + line);
                    }
                    if (!line.contains("{")) {
                        terminate(lineNumber, "Error: Missing '{' after ELSE THEN → " + line);
                    }

                    // ✅ If already executed one branch → skip this
                    if (skipElse) {
                        skipBlock(br);
                        continue;
                    }

                    StringBuilder block = new StringBuilder();
                    int braceCount = 1; // We already have one opening brace from ELSE THEN {
                    while ((line = br.readLine()) != null && braceCount > 0) {
                        String trimmedLine = line.trim();
                        // Check for closing brace first
                        if (trimmedLine.contains("}")) braceCount--;
                        if (braceCount > 0 && trimmedLine.contains("{")) braceCount++;
                        if (braceCount > 0) {
                        block.append(line).append("\n");
                        }
                    }

                    executeBlock(block.toString(), variables);

                    // ✅ End of the IF-ELSE chain
                    inIfChain = false;
                    skipElse = false;
                    continue;
                } else if (line.startsWith("WHILE ")) {
                    Pattern pattern = Pattern.compile("^WHILE\\s+\\[(.*?)\\]\\s+THEN\\s*\\{$");
                    Matcher matcher = pattern.matcher(line);

                    if (!matcher.find()) {
                        terminate(lineNumber, "Error: Invalid WHILE syntax → " + line);
                    }

                    String condition = matcher.group(1).trim();

                    // Gather block
                    StringBuilder blockBuilder = new StringBuilder();
                    int braceCount = 1;
                    while ((line = br.readLine()) != null) {
                        line = line.trim();
                        if (line.contains("{")) braceCount++;
                        if (line.contains("}")) braceCount--;
                        if (braceCount == 0) break;
                        blockBuilder.append(line).append("\n");
                    }

                    // Execute WHILE loop with safety counter
                    int loopCount = 0;
                    int maxLoops = 10000; // Prevent infinite loops
                    
                    while (evaluateBooleanExpression(condition, variables)) {
                        if (++loopCount > maxLoops) {
                            terminate(lineNumber, "Error: Maximum loop iterations exceeded. Possible infinite loop detected.");
                        }
                        
                        Interpreter inner = new Interpreter();
                        inner.variables = new HashMap<>(variables);
                        inner.inLoop = true; // Mark that we're inside a loop

                        // Add support for BREAK/CONTINUE inside this loop
                        inner.executeBlockInternal(blockBuilder.toString());

                        // Copy modified variables back to outer scope
                        variables.putAll(inner.variables);

                        if (inner.breakFlag) break;      // Stop loop if BREAK triggered
                        if (inner.continueFlag) continue; // Skip to next iteration
                    }
                }

            else if (line.startsWith("SELECT")) {
                // Syntax: SELECT [expr] THEN { ... }
                int bracketStart = line.indexOf('[');
                int bracketEnd = line.lastIndexOf(']');
                if (bracketStart == -1 || bracketEnd == -1 || bracketEnd < bracketStart) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing [expr] → " + line);
                }
                String selectorExpr = line.substring(bracketStart + 1, bracketEnd).trim();
                
                // Check for THEN keyword
                String afterBracket = line.substring(bracketEnd + 1).trim();
                if (!afterBracket.startsWith("THEN")) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing THEN → " + line);
                }
                
                // Check for opening brace
                if (!afterBracket.contains("{")) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing { → " + line);
                }

                // Collect block lines until matching }
                StringBuilder blockBuilder = new StringBuilder();
                int braceCount = 1; // we already saw the opening {
                while ((line = br.readLine()) != null) {
                    String raw = line;
                    line = line.trim();
                    if (line.contains("{")) braceCount++;
                    if (line.contains("}")) braceCount--;
                    if (braceCount == 0) break;
                    blockBuilder.append(raw).append("\n");
                }

                executeSelectBlock(selectorExpr, blockBuilder.toString(), variables, lineNumber);
                continue;
            }


                // Handle NUMBER variable declarations (integers)
                else if (line.startsWith("NUMBER")) {
                        line = line.replace("NUMBER", "").trim();
                        // Remove semicolon from the end
                        if (line.endsWith(";")) {
                            line = line.substring(0, line.length() - 1).trim();
                        }
                        String[] parts = line.split("=");
                        String varName = parts[0].trim();
                        
                        // Validate variable name syntax
                        LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, lineNumber);
                        if (!analyzer.validateVariableName(varName)) {
                            terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                        }
                        
                        if (isDataTypeKeyword(varName)) {
                            terminate(lineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                        }
                        if (isReservedKeyword(varName)) {
                            terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                        }

                        if (parts.length < 2) {
                            variables.put(varName, 0);
                            continue; 
                        }
                        String valueExpr = parts[1].trim();

                        try {
                            double result = evaluateExpression(valueExpr, variables);
                            // Truncate decimal places (remove fractional part)
                            int truncatedValue = (int) result;
                            variables.put(varName, truncatedValue);
                        } catch (Exception e) {
                            terminate(lineNumber, "Error: Invalid NUMBER expression — must contain only numeric or valid variable values.");
                        }

                    // Handle DECIMAL variable declarations (floating-point numbers)
                    } else if (line.startsWith("DECIMAL")) {
                    line = line.replace("DECIMAL", "").trim();
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String[] parts = line.split("=");
                    String varName = parts[0].trim();
                    
                    // Validate variable name syntax
                    LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, lineNumber);
                    if (!analyzer.validateVariableName(varName)) {
                        terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                    }
                    
                    if (isDataTypeKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                    }
                    if (isReservedKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                    }
                   
                    if (parts.length < 2) {
                        variables.put(varName, 0.0);
                        continue; // go to next line
                    }

                    String valueExpr = parts[1].trim();

                    try {
                        double result = evaluateExpression(valueExpr, variables);
                        variables.put(varName, result);
                    } catch (Exception e) {
                        terminate(lineNumber, "Error: Invalid DECIMAL expression — must contain only numeric or valid variable values.");
                        
                    }

                // Handle LETTER variable declarations (single characters)
                } else if (line.startsWith("LETTER")) {
                    line = line.replace("LETTER", "").trim();
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String[] parts = line.split("=");
                    String varName = parts[0].trim();

                    // Validate variable name syntax
                    LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, lineNumber);
                    if (!analyzer.validateVariableName(varName)) {
                        terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                    }

                    if (isDataTypeKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                    }
                    if (isReservedKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                    }

                    
                    // Allow declaration without initialization
                    if (parts.length < 2) {
                        variables.put(varName, ' ');
                        continue;
                    }

                    String valueStr = parts[1].trim();

                    // 🚫 Strict validation for LETTER initialization
                    if (valueStr.startsWith("\"") || valueStr.endsWith("\"")) {
                        terminate(lineNumber, "Error: LETTER cannot use double quotes. Use single quotes for single characters only.");
                    }

                    if (!valueStr.startsWith("'") || !valueStr.endsWith("'")) {
                        terminate(lineNumber, "Error: LETTER must be enclosed in single quotes ('A').");
                    }

                    if (valueStr.length() != 3) {
                        terminate(lineNumber, "Error: LETTER must contain exactly one character inside single quotes (e.g., 'A').");
                    }

                    // ✅ Passed all checks — store as char
                    variables.put(varName, valueStr.charAt(1));
                // Handle MESSAGE variable declarations (strings)
                }  else if (line.startsWith("MESSAGE")) {
                        line = line.replace("MESSAGE", "").trim();
                        // Remove semicolon from the end
                        if (line.endsWith(";")) {
                            line = line.substring(0, line.length() - 1).trim();
                        }
                        
                        String varName;
                        String valueStr = null;
                        
                        if (line.contains("=")) {
                            String[] parts = line.split("=", 2);
                            varName = parts[0].trim();
                            valueStr = parts[1].trim();
                        } else {
                            varName = line.trim();
                        }

                        // Validate variable name syntax
                        LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, lineNumber);
                        if (!analyzer.validateVariableName(varName)) {
                            terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                        }

                        if (isDataTypeKeyword(varName)) {
                            terminate(lineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                        }
                        if (isReservedKeyword(varName)) {
                            terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                        }

                        // Handle no initialization
                        if (valueStr == null) {
                            variables.put(varName, "");
                            continue;
                        }

                        // Strict quote checking (as before)
                        if (valueStr.startsWith("'") || valueStr.endsWith("'")) {
                            terminate(lineNumber, "Error: MESSAGE cannot use single quotes. Use double quotes for strings.");
                        }
                        if (!valueStr.startsWith("\"") && !valueStr.endsWith("\"") && !valueStr.contains("+")) {
                            terminate(lineNumber, "Error: MESSAGE must use double quotes or valid concatenation.");
                        }

                        // ✅ Now call the new expression evaluator
                        String result = evaluateMessageExpression(valueStr, variables, lineNumber);
                        variables.put(varName, result);
                // Handle BINARY variable declarations (boolean values)
                } else if (line.startsWith("BINARY")) {
                    line = line.replace("BINARY", "").trim();
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String[] parts = line.split("=");
                    String varName = parts[0].trim();
                    String valueExpr = parts[1].trim();

                    // Validate variable name syntax
                    LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, lineNumber);
                    if (!analyzer.validateVariableName(varName)) {
                        terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                    }

                    if (isDataTypeKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                    }
                    if (isReservedKeyword(varName)) {
                        terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                    }

                    

                    try {
                        boolean result = evaluateBinaryExpression(valueExpr, variables);
                        variables.put(varName, result ? "TRUE" : "FALSE");
                    } catch (Exception e) {
                        terminate("Error evaluating BINARY expression: " + e.getMessage());
                    }
                // Handle ASK statements (user input)
                } else if (line.contains("ASK:")) {
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String[] parts = line.split("ASK:");
                    if (parts.length < 2) {
                        System.out.println("Error: Invalid ASK syntax.");
                        continue;
                    }

                    String varName = parts[0].trim();
                    String message = parts[1].trim();
                    
                    // Handle quoted message
                    if (message.startsWith("\"") && message.endsWith("\"")) {
                        message = message.substring(1, message.length() - 1);
                    } else {
                        terminate(lineNumber, "Error: ASK message must be in double quotes.");
                    }

                    // ✅ FIX: ensure varName doesn't accidentally include ASK or extra symbols
                    varName = varName.replaceAll("[^a-zA-Z0-9_]", "");

                    if (!variables.containsKey(varName)) {
                        terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                        continue;
                    }

                    // Print prompt and get input on same line
                    System.out.print(message);
                    String userInput = scanner.nextLine();

                    Object value = variables.get(varName);
                    try {
                        if (value instanceof Integer) {
                            variables.put(varName, Integer.parseInt(userInput));
                        } else if (value instanceof Double) {
                            variables.put(varName, Double.parseDouble(userInput));
                        } else if (value instanceof Character) {
                            if (userInput.length() == 1) {
                                variables.put(varName, userInput.charAt(0));
                            } else {
                                terminate(lineNumber, "Error: Invalid input for LETTER, only one character is allowed.");
                            }
                        } else if (value instanceof String) {
                            // Check if it's a BINARY variable (stored as "TRUE" or "FALSE")
                            if (value.equals("TRUE") || value.equals("FALSE")) {
                                if (userInput.equalsIgnoreCase("TRUE") || userInput.equalsIgnoreCase("FALSE")) {
                                    variables.put(varName, userInput.toUpperCase());
                                } else {
                                    terminate(lineNumber, "Error: Invalid input for BINARY, must be TRUE or FALSE only.");
                                }
                            } else {
                                variables.put(varName, userInput);
                            }
                        }
                    } catch (Exception e) {
                        terminate(lineNumber, "Error: Invalid input for " + varName + ".");
                    }
                // Handle variable assignments (updating existing variables)
                } else if (line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*=.*")) {
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String[] parts = line.split("=", 2);
                    String varName = parts[0].trim();
                    String valueExpr = parts[1].trim();

                    if (!variables.containsKey(varName)) {
                        terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                    }

                    Object oldValue = variables.get(varName);

                    try {
                        if (oldValue instanceof Integer) {
                            double result = evaluateExpression(valueExpr, variables);
                            // Truncate decimal places (remove fractional part)
                            int truncatedValue = (int) result;
                            variables.put(varName, truncatedValue);
                        } else if (oldValue instanceof Double) {
                            double result = evaluateExpression(valueExpr, variables);
                            variables.put(varName, result);
                        } else if (oldValue instanceof Character) {
                            if (valueExpr.length() == 3 && valueExpr.startsWith("'") && valueExpr.endsWith("'")) {
                                variables.put(varName, valueExpr.charAt(1));
                            } else {
                                terminate(lineNumber, "Error: LETTER must be assigned using single quotes.");
                            }
                        } else if (oldValue instanceof String) {
                            // Check if it's a BINARY variable (stored as "TRUE" or "FALSE")
                            if (oldValue.equals("TRUE") || oldValue.equals("FALSE")) {
                                // It's a BINARY variable
                            if (valueExpr.equalsIgnoreCase("TRUE") || valueExpr.equalsIgnoreCase("FALSE")) {
                                variables.put(varName, valueExpr.toUpperCase());
                            } else {
                                terminate(lineNumber, "Error: Invalid value for BINARY variable.");
                                }
                            } else {
                                // It's a MESSAGE variable
                                if (valueExpr.startsWith("\"") && valueExpr.endsWith("\"")) {
                                    String rawString = valueExpr.substring(1, valueExpr.length() - 1);
                                    variables.put(varName, processEscapeSequences(rawString));
                                } else {
                                    terminate(lineNumber, "Error: MESSAGE must be assigned using double quotes.");
                                }
                            }
                        }
                    } catch (Exception e) {
                        terminate(lineNumber, "Error assigning value to variable '" + varName + "'.");
                    }
                // Handle SHOW statements (output)
                } else if (line.startsWith("SHOW")) {
                    if (!line.startsWith("SHOW:")) {
                        terminate(lineNumber, "Error: Invalid SHOW syntax. Use 'SHOW:'");
                    }
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String payload = line.substring(5).trim();

                    try {
                        if (payload.isEmpty()) {
                            // Empty SHOW statement
                            System.out.println();
                        } else if (payload.contains("@(")) {
                            // Handle variable interpolation with @(variableName) syntax
                            // Remove outer quotes if present
                            if (payload.startsWith("\"") && payload.endsWith("\"")) {
                                payload = payload.substring(1, payload.length() - 1);
                            }
                            String result = processVariableInterpolation(payload, variables);
                            System.out.println(result);
                        } else if (payload.startsWith("\"") && payload.endsWith("\"")) {
                            // Handle string literals with escape sequences
                            String stringValue = payload.substring(1, payload.length() - 1);
                            String processedValue = processEscapeSequences(stringValue);
                            System.out.println(processedValue);
                        } else if (payload.startsWith("(") && payload.endsWith(")") && !payload.contains("EQUAL") && !payload.contains("LESS") && !payload.contains("GREATER") && !payload.contains("NOT")) {
                            // Handle boolean/comparison expressions wrapped in parentheses (simple cases)
                            String condition = payload.substring(1, payload.length() - 1).trim();
                            boolean result = evaluateBinaryExpression(condition, variables);
                            System.out.println(result ? "TRUE" : "FALSE");
                        } else if (isBooleanExpression(payload)) {
                            // Handle boolean/comparison expressions (with EQUAL, NOT EQUAL, etc.)
                            boolean result = evaluateBinaryExpression(payload, variables);
                            System.out.println(result ? "TRUE" : "FALSE");
                        } else if (isArithmeticExpression(payload, variables)) {
                            // Handle arithmetic expressions (NUMBER/DECIMAL calculations)
                            double result = evaluateExpression(payload, variables, lineNumber);
                            // Check if result should be displayed as integer or decimal
                            if (result == (long) result) {
                                System.out.println((long) result);
                        } else {
                                System.out.println(result);
                            }
                        } else {
                            // Handle string concatenation using MESSAGE expression logic
                            String result = evaluateMessageExpression(payload, variables, lineNumber);
                            System.out.println(result);
                        }

                    } catch (Exception e) {
                        terminate(lineNumber, "Error: Invalid SHOW syntax or expression.");
                    }
                // Handle CONTINUE statements (loop control)
                } else if (line.equals("CONTINUE;")) {
                    if (!inLoop) {
                        terminate(lineNumber, "Error: 'CONTINUE' used outside a loop.");
                    }
                    this.continueFlag = true;
                    break;
                }

                // Handle BREAK statements (loop control)
                else if (line.equals("BREAK;")) {
                    if (!inLoop) {
                        terminate(lineNumber, "Error: 'BREAK' used outside a loop.");
                    }
                    this.breakFlag = true;
                    break;
                }


                // Handle RETURN statements (program termination)
                else if (line.startsWith("RETURN")) {
                    // Remove semicolon from the end
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1).trim();
                    }
                    String returnValue = line.substring(6).trim(); // get letter after RETURN

                    if (returnValue.isEmpty()) {
                        System.out.println("Returned with no value.");
                    } else {
                        // Check if RETURN value is valid
                        if (variables.containsKey(returnValue)) {
                            System.out.println("Returned value: " + variables.get(returnValue));
                        } else if (returnValue.matches("^\\d+(\\.\\d+)?$")) {
                            System.out.println("Returned value: " + returnValue);
                        } else if (returnValue.startsWith("\"") && returnValue.endsWith("\"")) {
                            System.out.println("Returned value: " + returnValue.substring(1, returnValue.length() - 1));
                        } else {
                            terminate(lineNumber, "Error: Invalid RETURN value → " + returnValue);
                        }
                    }

                    System.exit(0); // stop execution after RETURN
                }


            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Executes code directly from a string (used when comments have been removed)
     * @param code The code to execute (without comments)
     */
    public void executeCode(String code) {
        String[] lines = code.split("\n");
        int lineNumber = 0;
        
        // Process each line of the source code
        for (int i = 0; i < lines.length; i++) {
            lineNumber++;
            String line = lines[i].trim();
            
            // Skip empty lines
            if (line.isEmpty()) {
                continue;
            }
            
            // Skip standalone closing braces (they're handled by block processing)
            if (line.equals("}")) {
                continue;
            }
            
            // Validate line contains only allowed characters (including @() for variable interpolation, # for comments, and \\ for escape sequences)
            if (!line.matches("[a-zA-Z0-9_\\s\"'()+\\-*/%=<>!.,:{}\\[\\];@$#\\\\]*")) {
                terminate(lineNumber, "Error: Invalid or unnecessary character found → " + line);
            }
            
            // Explicitly reject // comments - HumanLang only supports # comments
            if (line.contains("//")) {
                terminate(lineNumber, "Error: '//' comments are not allowed. Use # comment # syntax instead → " + line);
            }
            
            // Handle IF statements
            if (line.startsWith("IF")) {
                if (!line.contains("THEN")) {
                    terminate(lineNumber, "Error: Missing THEN in IF statement → " + line);
                }
                if (!line.contains("{")) {
                    terminate(lineNumber, "Error: Missing '{' after THEN in IF statement → " + line);
                }

                // Process the entire IF-ELSE IF-ELSE chain and update index
                i = processIfChainAndGetEndIndex(lines, i, lineNumber);
                continue;
            }
            
            
            // Handle WHILE loops
            if (line.startsWith("WHILE")) {
                if (!line.contains("THEN")) {
                    terminate(lineNumber, "Error: Missing THEN in WHILE statement → " + line);
                }
                if (!line.contains("{")) {
                    terminate(lineNumber, "Error: Missing '{' after THEN in WHILE statement → " + line);
                }
                
                // Extract condition from WHILE statement
                String condition = extractCondition(line, lineNumber);
                
                // Read block content from subsequent lines
                StringBuilder blockBuilder = new StringBuilder();
                int braceCount = 1; // We already have one opening brace
                i++; // Move to next line
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i].trim();
                    if (blockLine.contains("{")) {
                        braceCount++;
                    }
                    if (blockLine.contains("}")) {
                        braceCount--;
                    }
                        if (braceCount > 0) {
                        blockBuilder.append(blockLine).append("\n");
                    }
                    i++;
                }
                i--; // Adjust for the loop increment
                String block = blockBuilder.toString();
                
                // Execute the loop
                boolean wasInLoop = this.inLoop;
                this.inLoop = true; // Mark that we're inside a loop
                while (evaluateBinaryExpression(condition, variables, lineNumber)) {
                    executeBlockInternal(block);
                    
                    // Check for break flag
                    if (this.breakFlag) {
                        this.breakFlag = false;
                        break;
                    }
                    
                    // Check for continue flag
                    if (this.continueFlag) {
                        this.continueFlag = false;
                        continue;
                    }
                }
                this.inLoop = wasInLoop; // Restore previous loop state
                continue;
            }

            // Handle SELECT (switch) blocks
            if (line.startsWith("SELECT")) {
                // Extract condition from SELECT statement
                int bracketStart = line.indexOf('[');
                int bracketEnd = line.lastIndexOf(']');
                if (bracketStart == -1 || bracketEnd == -1 || bracketEnd < bracketStart) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing [expr] → " + line);
                }
                String selectorExpr = line.substring(bracketStart + 1, bracketEnd).trim();
                
                // Check for THEN keyword
                String afterBracket = line.substring(bracketEnd + 1).trim();
                if (!afterBracket.startsWith("THEN")) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing THEN → " + line);
                }
                
                // Check for opening brace
                if (!afterBracket.contains("{")) {
                    terminate(lineNumber, "Error: Invalid SELECT syntax - missing { → " + line);
                }

                // Read block content
                StringBuilder blockBuilder = new StringBuilder();
                int braceCount = 1; // We already have one opening brace
                i++; // Move to next line
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i];
                    String trimmed = blockLine.trim();
                    if (trimmed.contains("{")) braceCount++;
                    if (trimmed.contains("}")) braceCount--;
                    if (braceCount > 0) {
                        blockBuilder.append(blockLine).append("\n");
                    }
                    i++;
                }
                i--; // Adjust for loop increment

                executeSelectBlock(selectorExpr, blockBuilder.toString(), variables, lineNumber);
                continue;
            }
            
            // Handle BREAK statements (loop control)
            if (line.equals("BREAK;")) {
                if (!inLoop) {
                    terminate(lineNumber, "Error: 'BREAK' used outside a loop.");
                }
                this.breakFlag = true;
                break;
            }
            
            // Handle CONTINUE statements (loop control)
            if (line.equals("CONTINUE;")) {
                if (!inLoop) {
                    terminate(lineNumber, "Error: 'CONTINUE' used outside a loop.");
                }
                this.continueFlag = true;
                break;
            }
            if (line.startsWith("RETURN ")) {
                handleReturn(line, lineNumber);
                this.returnFlag = true;
                return; // Exit block execution
            }
            
            // Skip TASK definitions (already parsed in preprocessing)
            if (line.startsWith("TASK") && line.contains("DO {")) {
                // Skip the entire TASK block
                i = skipTASKBlock(lines, i);
                continue;
            }
            if (line.split(" ").length > 1 && Arrays.asList("NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY").contains(line.split(" ")[0]) && line.split(" ")[1].equals("TASK") && line.contains("DO {")) {
                // Skip the entire TASK block
                i = skipTASKBlock(lines, i);
                continue;
            }

            // Handle NUMBER variable declarations (integers)
                if (line.startsWith("NUMBER ")) {
                line = line.replace("NUMBER", "").trim();
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name
                LexicalAnalyzer nameAnalyzer = new LexicalAnalyzer(varName, lineNumber);
                if (!nameAnalyzer.validateVariableName(varName)) {
                    terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                // Check if variable name is a reserved keyword
                if (isReservedKeyword(varName)) {
                    terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                

                if (valueExpr == null) {
                    variables.put(varName, 0);
                    continue;
                }
                
                try {
                    double result = evaluateExpression(valueExpr, variables, lineNumber);
                    // Truncate decimal places (remove fractional part)
                    int truncatedValue = (int) result;
                    variables.put(varName, truncatedValue);
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid NUMBER expression — must contain only numeric or valid variable values.");
                }
                continue;
            }
            
            // Handle DECIMAL variable declarations (floating-point numbers)
            if (line.startsWith("DECIMAL ")) {
                line = line.replace("DECIMAL", "").trim();
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name
                LexicalAnalyzer nameAnalyzer = new LexicalAnalyzer(varName, lineNumber);
                if (!nameAnalyzer.validateVariableName(varName)) {
                    terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                // Check if variable name is a reserved keyword
                if (isReservedKeyword(varName)) {
                    terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                

                if (valueExpr == null) {
                    variables.put(varName, 0.0);
                    continue;
                }
                
                try {
                    double result = evaluateExpression(valueExpr, variables, lineNumber);
                    variables.put(varName, result);
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid DECIMAL expression — must contain only numeric or valid variable values.");
                }
                continue;
            }
            
            // Handle LETTER variable declarations (single characters)
            if (line.startsWith("LETTER ")) {
                line = line.replace("LETTER", "").trim();
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String value = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    value = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name
                LexicalAnalyzer nameAnalyzer = new LexicalAnalyzer(varName, lineNumber);
                if (!nameAnalyzer.validateVariableName(varName)) {
                    terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                // Check if variable name is a reserved keyword
                if (isReservedKeyword(varName)) {
                    terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                

                if (value == null) {
                    variables.put(varName, ' ');
                    continue;
                }
                
                if (value.startsWith("'") && value.endsWith("'") && value.length() == 3) {
                    variables.put(varName, value.charAt(1));
                } else {
                    terminate(lineNumber, "Error: LETTER must be assigned a single character in single quotes → " + line);
                }
                continue;
            }
            
            // Handle MESSAGE variable declarations (strings)
            if (line.startsWith("MESSAGE ")) {
                line = line.replace("MESSAGE", "").trim();
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name
                LexicalAnalyzer nameAnalyzer = new LexicalAnalyzer(varName, lineNumber);
                if (!nameAnalyzer.validateVariableName(varName)) {
                    terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                // Check if variable name is a reserved keyword
                if (isReservedKeyword(varName)) {
                    terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
                

                if (valueExpr == null) {
                    variables.put(varName, "");
                    continue;
                }
                try {
                    String result = evaluateMessageExpression(valueExpr, variables, lineNumber);
                    variables.put(varName, result);
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid MESSAGE expression → " + line);
                }
                continue;
            }
            
            // Handle BINARY variable declarations (boolean values)
            if (line.startsWith("BINARY ")) {
                line = line.replace("BINARY", "").trim();
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name
                LexicalAnalyzer nameAnalyzer = new LexicalAnalyzer(varName, lineNumber);
                if (!nameAnalyzer.validateVariableName(varName)) {
                    terminate(lineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                // Check if variable name is a reserved keyword
                if (isReservedKeyword(varName)) {
                    terminate(lineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
               

                if (valueExpr == null) {
                    variables.put(varName, "FALSE");
                    continue;
                }
                
                try {
                    boolean result = evaluateBinaryExpression(valueExpr, variables, lineNumber);
                    variables.put(varName, result ? "TRUE" : "FALSE");
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid BINARY expression.");
                }
                continue;
            }
            
            // Handle ASK statements (user input)
            if (line.contains("ASK:")) {
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("ASK:");
                if (parts.length < 2) {
                    terminate(lineNumber, "Error: Invalid ASK syntax → " + line);
                }
                String varName = parts[0].trim();
                String message = parts[1].trim();

                // Validate and extract message inside double quotes
                if (message.startsWith("\"") && message.endsWith("\"")) {
                    message = message.substring(1, message.length() - 1);
                } else if (!message.isEmpty()) {
                    terminate(lineNumber, "Error: ASK message must be in double quotes.");
                }

                // Clean up variable name (avoid stray symbols)
                varName = varName.replaceAll("[^a-zA-Z0-9_]", "");

                // Check if variable exists
                if (!variables.containsKey(varName)) {
                    terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                }
                
                // Print prompt and get input on same line
                if (!message.isEmpty()) {
                    System.out.print(message);
                }
                String userInput = scanner.nextLine();
                
                try {
                    Object value = variables.get(varName);
                    if (value instanceof Integer) {
                        variables.put(varName, Integer.parseInt(userInput));
                    } else if (value instanceof Double) {
                        variables.put(varName, Double.parseDouble(userInput));
                    } else if (value instanceof Character) {
                        if (userInput.length() == 1) {
                            variables.put(varName, userInput.charAt(0));
                        } else {
                            terminate(lineNumber, "Error: Invalid input for LETTER, only one character is allowed.");
                        }
                    } else if (value instanceof String) {
                        // Check if it's a BINARY variable (stored as "TRUE" or "FALSE")
                        if (value.equals("TRUE") || value.equals("FALSE")) {
                            if (userInput.equalsIgnoreCase("TRUE") || userInput.equalsIgnoreCase("FALSE")) {
                                variables.put(varName, userInput.toUpperCase());
                            } else {
                                terminate(lineNumber, "Error: Invalid input for BINARY, must be TRUE or FALSE only.");
                            }
                        } else {
                            variables.put(varName, userInput);
                        }
                    }
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid input for " + varName + ".");
                }
                continue;
            }
            
                // Handle increment/decrement statements (x++; ++x; x--; --x;)
                if (line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*(\\+\\+|--)\\s*;?$")) {
                    String varName = line.replace(";", "").trim();
                    varName = varName.replaceAll("(\\+\\+|--)$", "").trim();
                    if (!variables.containsKey(varName)) {
                        terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                    }
                    Object current = variables.get(varName);
                    boolean isIncrement = line.contains("++");
                    if (current instanceof Integer) {
                        int v = (Integer) current;
                        variables.put(varName, isIncrement ? v + 1 : v - 1);
                    } else if (current instanceof Double) {
                        double v = (Double) current;
                        variables.put(varName, isIncrement ? v + 1.0 : v - 1.0);
                    } else {
                        terminate(lineNumber, "Error: Increment/Decrement allowed only for NUMBER or DECIMAL variables.");
                    }
                    continue;
                }

                if (line.matches("^(\\+\\+|--)\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*;?$")) {
                    String cleaned = line.replace(";", "").trim();
                    boolean isIncrement = cleaned.startsWith("++");
                    String varName = cleaned.replaceFirst("^(\\+\\+|--)", "").trim();
                    if (!variables.containsKey(varName)) {
                        terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                    }
                    Object current = variables.get(varName);
                    if (current instanceof Integer) {
                        int v = (Integer) current;
                        variables.put(varName, isIncrement ? v + 1 : v - 1);
                    } else if (current instanceof Double) {
                        double v = (Double) current;
                        variables.put(varName, isIncrement ? v + 1.0 : v - 1.0);
                    } else {
                        terminate(lineNumber, "Error: Increment/Decrement allowed only for NUMBER or DECIMAL variables.");
                    }
                    continue;
                }

                // Handle variable assignments (updating existing variables)
            if (line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*=.*")) {
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("=", 2);
                String varName = parts[0].trim();
                
                // Check if variable exists
                if (!variables.containsKey(varName)) {
                    terminate(lineNumber, "Error: Variable '" + varName + "' not declared.");
                }
                
                String valueExpr = parts[1].trim();
                try {
                    Object value = variables.get(varName);
                    if (value instanceof Integer) {
                        double result = evaluateExpression(valueExpr, variables, lineNumber);
                        // Truncate decimal places (remove fractional part)
                        int truncatedValue = (int) result;
                        variables.put(varName, truncatedValue);
                    } else if (value instanceof Double) {
                        double result = evaluateExpression(valueExpr, variables, lineNumber);
                        variables.put(varName, result);
                    } else if (value instanceof Character) {
                        if (valueExpr.startsWith("'") && valueExpr.endsWith("'") && valueExpr.length() == 3) {
                            variables.put(varName, valueExpr.charAt(1));
                        } else {
                            terminate(lineNumber, "Error: LETTER must be assigned a single character in single quotes.");
                        }
                    } else if (value instanceof String) {
                        if (valueExpr.startsWith("\"") && valueExpr.endsWith("\"")) {
                            // Handle string literals with escape sequences
                            String stringValue = valueExpr.substring(1, valueExpr.length() - 1);
                            String processedValue = processEscapeSequences(stringValue);
                            variables.put(varName, processedValue);
                        } else {
                            // Handle string concatenation
                            String result = evaluateMessageExpression(valueExpr, variables, lineNumber);
                            variables.put(varName, result);
                        }
                    } else if (value.equals("TRUE") || value.equals("FALSE")) {
                        boolean result = evaluateBinaryExpression(valueExpr, variables, lineNumber);
                        variables.put(varName, result ? "TRUE" : "FALSE");
                    }
                } catch (Exception e) {
                    terminate(lineNumber, "Error assigning value to variable '" + varName + "'.");
                }
                continue;
            }
            
            // Handle SHOW statements (output)
            if (line.startsWith("SHOW")) {
                if (!line.startsWith("SHOW:")) {
                    terminate(lineNumber, "Error: Invalid SHOW syntax. Use 'SHOW:'");
                }
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String payload = line.substring(5).trim();
                
                try {
                    if (payload.isEmpty()) {
                        // Empty SHOW statement
                        System.out.println();
                    } else if (payload.contains("@(")) {
                        // Handle variable interpolation with @(variableName) syntax
                        // Remove outer quotes if present
                        if (payload.startsWith("\"") && payload.endsWith("\"")) {
                            payload = payload.substring(1, payload.length() - 1);
                        }
                        String result = processVariableInterpolation(payload, variables);
                        System.out.println(result);
                    } else if (payload.startsWith("\"") && payload.endsWith("\"")) {
                        // Handle string literals with escape sequences
                        String stringValue = payload.substring(1, payload.length() - 1);
                        String processedValue = processEscapeSequences(stringValue);
                        System.out.println(processedValue);
                    } else if (payload.startsWith("(") && payload.endsWith(")") && !payload.contains("EQUAL") && !payload.contains("LESS") && !payload.contains("GREATER") && !payload.contains("NOT")) {
                        // Handle boolean/comparison expressions wrapped in parentheses (simple cases)
                        String condition = payload.substring(1, payload.length() - 1).trim();
                        boolean result = evaluateBinaryExpression(condition, variables, lineNumber);
                        System.out.println(result ? "TRUE" : "FALSE");
                    } else if (isBooleanExpression(payload)) {
                        // Handle boolean/comparison expressions (with EQUAL, NOT EQUAL, etc.)
                        boolean result = evaluateBinaryExpression(payload, variables, lineNumber);
                        System.out.println(result ? "TRUE" : "FALSE");
                    } else if (isArithmeticExpression(payload, variables)) {
                        // Handle arithmetic expressions (NUMBER/DECIMAL calculations)
                        double result = evaluateExpression(payload, variables, lineNumber);
                        // Check if result should be displayed as integer or decimal
                        if (result == (long) result) {
                            System.out.println((long) result);
                    } else {
                            System.out.println(result);
                        }
                    } else {
                        // Handle string concatenation using MESSAGE expression logic
                        String result = evaluateMessageExpression(payload, variables, lineNumber);
                        System.out.println(result);
                    }
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid SHOW syntax or expression.");
                }
                continue;
            }
            
            // Handle function calls
            if (isFunctionCall(line)) {
                try {
                    executeFunctionCall(line, lineNumber);
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Function call failed → " + line);
                }
                continue;
            }
            
            // If we reach here, the line is not recognized
            terminate(lineNumber, "Error: Unrecognized statement → " + line);
        }
    }
    
    /**
     * Processes an entire IF-ELSE IF-ELSE chain
     * @param lines The array of lines
     * @param startIndex The starting index of the IF statement
     * @param lineNumber The line number of the IF statement
     * @return the index of the last line in the IF chain
     */
    private int processIfChainAndGetEndIndex(String[] lines, int startIndex, int lineNumber) {
        int i = startIndex;
        String line = lines[i].trim();
        
        // Process IF statement
        String condition = extractCondition(line, lineNumber);
        boolean result = evaluateBinaryExpression(condition, variables, lineNumber);
        
        if (result) {
            // Execute IF block
            StringBuilder block = new StringBuilder();
            int braceCount = 1; // We already have one opening brace
            i++; // Move to next line
            String closingLine = null;
            while (i < lines.length && braceCount > 0) {
                String blockLine = lines[i].trim();
                // Check for closing brace first
                if (blockLine.contains("}")) {
                    braceCount--;
                    closingLine = blockLine;
                }
                if (braceCount > 0 && blockLine.contains("{")) {
                    braceCount++;
                }
                    if (braceCount > 0) {
                    block.append(blockLine).append("\n");
                }
                i++;
            }
            i--; // Back up to the closing line
            executeBlockInternal(block.toString());
            
            // Check if the closing line has ELSE on it (handle both }ELSE and } ELSE)
            if (closingLine != null && (closingLine.startsWith("}ELSE") || closingLine.startsWith("} ELSE"))) {
                // Process the ELSE from the closing line
                // Don't skip - let the code below process it
            } else {

            // Skip remaining ELSE IF/ELSE in chain and return final index
            while (i < lines.length) {
                    i++; // Move to next line
                    if (i >= lines.length) break;
                String nextLine = lines[i].trim();
                    if (nextLine.startsWith("ELSE IF") || nextLine.startsWith("ELSE") || nextLine.startsWith("} ELSE")) {
                    i++; // Skip the ELSE IF or ELSE line
                    // Skip the block content
                    int skipBraceCount = 1;
                    while (i < lines.length && skipBraceCount > 0) {
                        String skipLine = lines[i].trim();
                            if (skipLine.contains("{")) skipBraceCount++;
                            if (skipLine.contains("}")) skipBraceCount--;
                        i++;
                    }
                    i--; // Adjust because we increment at the end
                } else {
                        i--; // Back up since this line is not part of the chain
                    break; // End of IF chain
                }
                }
                return i;
            }
            
            // Process ELSE from closing line
            String nextLine = lines[i].trim();
            if (nextLine.startsWith("}ELSE IF") || nextLine.startsWith("} ELSE IF")) {
                // Handle }ELSE IF or } ELSE IF on same line - continue to ELSE IF processing below
            } else if (nextLine.startsWith("}ELSE") || nextLine.startsWith("} ELSE")) {
                // Handle }ELSE or } ELSE on same line
                // But we already executed the IF block, so we should SKIP the ELSE
                
                braceCount = 1;
                i++; // Move past the }ELSE THEN { or } ELSE THEN { line
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i].trim();
                    if (blockLine.contains("}")) braceCount--;
                    if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                    i++;
                }
                i--; 
                return i;
            }
            return i;
        } else {
            // Skip IF block
            int braceCount = 1; // We already have one opening brace
            i++; // Move to next line
            while (i < lines.length && braceCount > 0) {
                String blockLine = lines[i].trim();
                // Count all opening and closing braces on this line
                for (char c : blockLine.toCharArray()) {
                    if (c == '{') {
                        braceCount++;
                    } else if (c == '}') {
                        braceCount--;
                        // If we just closed the IF block and this line has ELSE, stop here
                        if (braceCount == 0 && (blockLine.contains("ELSE IF") || blockLine.contains("ELSE THEN"))) {
                            // Don't back up - we're already at the ELSE line
                            break;
                        }
                    }
                }
                if (braceCount > 0) {
                    i++;
                } else {
                    break; // We've closed the IF block
                }
            }
        }
        
        // Process ELSE IF statements
        // Don't increment i here because the block skipping already positioned us correctly
        while (i < lines.length) {
            String nextLine = lines[i].trim();
            // Handle `} ELSE IF` format
            if (nextLine.startsWith("} ELSE IF") || nextLine.startsWith("ELSE IF")) {
                if (!nextLine.contains("THEN")) {
                    terminate(lineNumber, "Error: Missing THEN in ELSE IF statement → " + nextLine);
                }
                if (!nextLine.contains("{")) {
                    terminate(lineNumber, "Error: Missing '{' after THEN in ELSE IF statement → " + nextLine);
                }
                
                // Extract condition from ELSE IF statement
                String elseIfCondition = extractCondition(nextLine, lineNumber);
                boolean elseIfResult = evaluateBinaryExpression(elseIfCondition, variables, lineNumber);
                
                if (elseIfResult) {
                    // Execute ELSE IF block
                    StringBuilder block = new StringBuilder();
                    int braceCount = 1; // We already have one opening brace
                    i++; // Move to next line
                    while (i < lines.length && braceCount > 0) {
                        String blockLine = lines[i].trim();
                        if (blockLine.equals("{")) {
                            braceCount++;
                        } else if (blockLine.equals("}")) {
                            braceCount--;
                            if (braceCount > 0) {
                                block.append(blockLine).append("\n");
                            }
                        } else {
                            block.append(blockLine).append("\n");
                        }
                        i++;
                    }
                    executeBlockInternal(block.toString());
                    // Skip remaining ELSE in chain and return final index
                    while (i < lines.length) {
                        String remainingLine = lines[i].trim();
                        if (remainingLine.startsWith("ELSE")) {
                            i++; // Skip the ELSE line
                            // Skip the block content
                            int skipBraceCount = 1;
                            i++; // Move to next line
                            while (i < lines.length && skipBraceCount > 0) {
                                String skipLine = lines[i].trim();
                                if (skipLine.equals("{")) {
                                    skipBraceCount++;
                                } else if (skipLine.equals("}")) {
                                    skipBraceCount--;
                                }
                                i++;
                            }
                            i--; // Adjust
                        } else {
                            break;
                        }
                    }
                    return i;
                } else {
                    // Skip ELSE IF block
                    int braceCount = 1; // We already have one opening brace
                    i++; // Move to next line
                    while (i < lines.length && braceCount > 0) {
                        String blockLine = lines[i].trim();
                        // Count all opening and closing braces on this line
                        for (char c : blockLine.toCharArray()) {
                            if (c == '{') {
                                braceCount++;
                            } else if (c == '}') {
                                braceCount--;
                                // If we just closed the ELSE IF block and this line has ELSE, stop here
                                if (braceCount == 0 && (blockLine.contains("ELSE THEN") || blockLine.startsWith("} ELSE"))) {
                                    // Don't back up - we're already at the ELSE line
                                    break;
                                }
                            }
                        }
                        if (braceCount > 0) {
                            i++;
                        } else {
                            break; // We've closed the ELSE IF block
                        }
                    }
                }
            } else if (nextLine.startsWith("} ELSE THEN") || nextLine.startsWith("} ELSE") || nextLine.startsWith("ELSE")) {
                if (!nextLine.contains("{")) {
                    terminate(lineNumber, "Error: Missing '{' after ELSE statement → " + nextLine);
                }
                
                // Execute ELSE block
                StringBuilder block = new StringBuilder();
                int braceCount = 1; // We already have one opening brace
                i++; // Move to next line
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i].trim();
                    if (blockLine.equals("{")) {
                        braceCount++;
                    } else if (blockLine.equals("}")) {
                        braceCount--;
                        if (braceCount > 0) {
                            block.append(blockLine).append("\n");
                        }
                    } else {
                        block.append(blockLine).append("\n");
                    }
                    i++;
                }
                i--; // Back up one
                executeBlockInternal(block.toString());
                return i; // Return final index
            } else {
                break; // End of IF chain
            }
        }
        
        return i; // Return final index
    }
    
    /**
     * Executes a block of code (used for IF/ELSE and WHILE blocks)
     * @param block The code block to execute
     * @param variables The variable context to use
     */
    private void executeBlock(String block, Map<String, Object> variables) {
        Interpreter inner = new Interpreter();
        inner.variables = new HashMap<>(variables); // pass current vars
        inner.inLoop = this.inLoop; // Preserve loop state
        inner.executeBlockInternal(block);
        
        // Copy modified variables back to outer scope
        variables.putAll(inner.variables);
        
        // Propagate break/continue flags
        this.breakFlag = inner.breakFlag;
        this.continueFlag = inner.continueFlag;
        
        // Propagate return values
        this.returnValue = inner.returnValue;
        this.returnFlag = inner.returnFlag;
    }

    /**
     * Handles internal block execution with proper variable scoping
     * @param block The code block to execute internally
     */
    private void executeBlockInternal(String block) {
        String[] lines = block.split("\n");
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i].trim();
            if (line.isEmpty()) continue;
            
            // Note: Line numbers in executeBlockInternal are relative to the block, not the main file
            int blockLineNumber = i + 1;

            // Handle IF statements
            if (line.startsWith("IF [")) {
                // Extract condition
                String condition = extractCondition(line);
                boolean conditionTrue = evaluateBooleanExpression(condition, variables);
                
                // Find the block content
                StringBuilder ifBlock = new StringBuilder();
                i++; // Move past IF line
                int braceCount = 1;
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i].trim();
                    // Check for closing brace first, before opening brace
                    if (blockLine.contains("}")) braceCount--;
                    if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                    if (braceCount > 0) {
                        ifBlock.append(blockLine).append("\n");
                    }
                    i++;
                }
                i--; // Back up one since loop will increment
                
                boolean executedBranch = false;
                if (conditionTrue) {
                    executeBlockInternal(ifBlock.toString());
                    executedBranch = true;
                }
                
                // Handle ELSE IF and ELSE
                // Check current line first (in case }ELSE is on same line as closing brace)
                String currentLine = (i < lines.length) ? lines[i].trim() : "";
                if (currentLine.startsWith("}ELSE") || currentLine.startsWith("} ELSE")) {
                    // Process the ELSE/ELSE IF on the current line
                    if (currentLine.startsWith("}ELSE IF [") || currentLine.startsWith("} ELSE IF [")) {
                        String elseIfCondition = extractCondition(currentLine);
                        StringBuilder elseIfBlock = new StringBuilder();
                        i++; // Move past ELSE IF line
                        braceCount = 1;
                        while (i < lines.length && braceCount > 0) {
                            String blockLine = lines[i].trim();
                            if (blockLine.contains("}")) braceCount--;
                            if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                            if (braceCount > 0) {
                                elseIfBlock.append(blockLine).append("\n");
                            }
                            i++;
                        }
                        i--; // Back up one
                        
                        if (!executedBranch && evaluateBooleanExpression(elseIfCondition, variables)) {
                            executeBlockInternal(elseIfBlock.toString());
                            executedBranch = true;
                        }
                    } else if (currentLine.startsWith("}ELSE THEN {") || currentLine.startsWith("} ELSE THEN {")) {
                        StringBuilder elseBlock = new StringBuilder();
                        i++; // Move past ELSE line
                        braceCount = 1;
                        while (i < lines.length && braceCount > 0) {
                            String blockLine = lines[i].trim();
                            if (blockLine.contains("}")) braceCount--;
                            if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                            if (braceCount > 0) {
                                elseBlock.append(blockLine).append("\n");
                            }
                            i++;
                        }
                        i--; // Back up one
                        
                        if (!executedBranch) {
                            executeBlockInternal(elseBlock.toString());
                        }
                    }
                    // Skip checking next lines since we processed the ELSE on current line
                    if (breakFlag || continueFlag) {
                        return;
                    }
                    continue;
                }
                
                while (i + 1 < lines.length) {
                    int nextIdx = i + 1;
                    if (nextIdx >= lines.length) break;
                    String nextLine = lines[nextIdx].trim();
                    
                    if (nextLine.startsWith("ELSE IF [") || nextLine.startsWith("}ELSE IF [") || nextLine.startsWith("} ELSE IF [")) {
                        i = nextIdx;
                        String elseIfCondition = extractCondition(nextLine);
                        StringBuilder elseIfBlock = new StringBuilder();
                        i++; // Move past ELSE IF line
                        braceCount = 1;
                        while (i < lines.length && braceCount > 0) {
                            String blockLine = lines[i].trim();
                            // Check for closing brace first, before opening brace
                            if (blockLine.contains("}")) braceCount--;
                            if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                            if (braceCount > 0) {
                                elseIfBlock.append(blockLine).append("\n");
                            }
                            i++;
                        }
                        i--; // Back up one
                        
                        if (!executedBranch && evaluateBooleanExpression(elseIfCondition, variables)) {
                            executeBlockInternal(elseIfBlock.toString());
                            executedBranch = true;
                        }
                    } else if (nextLine.startsWith("ELSE THEN {") || nextLine.startsWith("}ELSE THEN {") || nextLine.startsWith("} ELSE THEN {")) {
                        i = nextIdx;
                        StringBuilder elseBlock = new StringBuilder();
                        i++; // Move past ELSE line
                        braceCount = 1;
                        while (i < lines.length && braceCount > 0) {
                            String blockLine = lines[i].trim();
                            // Check for closing brace first, before opening brace
                            if (blockLine.contains("}")) braceCount--;
                            if (braceCount > 0 && blockLine.contains("{")) braceCount++;
                            if (braceCount > 0) {
                                elseBlock.append(blockLine).append("\n");
                            }
                            i++;
                        }
                        i--; // Back up one
                        
                        if (!executedBranch) {
                            executeBlockInternal(elseBlock.toString());
                        }
                        break; // End of IF-ELSE chain
                    } else {
                        break; // No more ELSE IF/ELSE
                    }
                }
                
                // Check if BREAK or CONTINUE was triggered after processing IF/ELSE chain
                if (breakFlag || continueFlag) {
                    return;
                }
                
                continue;
            }

            // Handle SELECT (switch) blocks
            if (line.startsWith("SELECT")) {
                // Extract condition from SELECT statement
                int bracketStart = line.indexOf('[');
                int bracketEnd = line.lastIndexOf(']');
                if (bracketStart == -1 || bracketEnd == -1 || bracketEnd < bracketStart) {
                    terminate(blockLineNumber, "Error: Invalid SELECT syntax - missing [expr] → " + line);
                }
                String selectorExpr = line.substring(bracketStart + 1, bracketEnd).trim();
                
                // Check for THEN keyword
                String afterBracket = line.substring(bracketEnd + 1).trim();
                if (!afterBracket.startsWith("THEN")) {
                    terminate(blockLineNumber, "Error: Invalid SELECT syntax - missing THEN → " + line);
                }
                
                // Check for opening brace
                if (!afterBracket.contains("{")) {
                    terminate(blockLineNumber, "Error: Invalid SELECT syntax - missing { → " + line);
                }

                // Read block content
                StringBuilder blockBuilder = new StringBuilder();
                int braceCount = 1; // We already have one opening brace
                i++; // Move to next line
                while (i < lines.length && braceCount > 0) {
                    String blockLine = lines[i];
                    String trimmed = blockLine.trim();
                    if (trimmed.contains("{")) braceCount++;
                    if (trimmed.contains("}")) braceCount--;
                    if (braceCount > 0) {
                        blockBuilder.append(blockLine).append("\n");
                    }
                    i++;
                }
                i--; // Adjust for loop increment

                executeSelectBlock(selectorExpr, blockBuilder.toString(), variables, blockLineNumber);
                continue;
            }

            // Skip TASK definitions (already parsed in preprocessing)
            if (line.startsWith("TASK") && line.contains("DO {")) {
                // Skip the entire TASK block
                i = skipTASKBlock(lines, i);
                continue;
            }
            if (line.split(" ").length > 1 && Arrays.asList("NUMBER", "DECIMAL", "LETTER", "MESSAGE", "BINARY").contains(line.split(" ")[0]) && line.split(" ")[1].equals("TASK") && line.contains("DO {")) {
                // Skip the entire TASK block
                i = skipTASKBlock(lines, i);
                continue;
            }

            // Handle NUMBER variable declarations
            if (line.startsWith("NUMBER ")) {
                line = line.replace("NUMBER", "").trim();
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("=");
                String varName = parts[0].trim();
                if (isDataTypeKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                }
                if (isReservedKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
                
                if (parts.length < 2) {
                    variables.put(varName, 0);
                    continue;
                }
                String valueExpr = parts[1].trim();
                try {
                    double result = evaluateExpression(valueExpr, variables);
                    int truncatedValue = (int) result;
                    variables.put(varName, truncatedValue);
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error: Invalid NUMBER expression — must contain only numeric or valid variable values.");
                }
                continue;
            }

            // Handle DECIMAL variable declarations
            if (line.startsWith("DECIMAL ")) {
                line = line.replace("DECIMAL", "").trim();
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                if (isDataTypeKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                }
                if (isReservedKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
                if (valueExpr == null) {
                    variables.put(varName, 0.0);
                    continue;
                }
                try {
                    double result = evaluateExpression(valueExpr, variables);
                    variables.put(varName, result);
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error: Invalid DECIMAL expression — must contain only numeric or valid variable values.");
                }
                continue;
            }

            // Handle LETTER variable declarations
            if (line.startsWith("LETTER ")) {
                line = line.replace("LETTER", "").trim();
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueStr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueStr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                if (isDataTypeKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                }
                if (isReservedKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
                if (valueStr == null) {
                    variables.put(varName, ' ');
                    continue;
                }
                if (valueStr.startsWith("\"") || valueStr.endsWith("\"")) {
                    terminate(blockLineNumber, "Error: LETTER cannot use double quotes. Use single quotes for single characters only.");
                }
                if (!valueStr.startsWith("'") || !valueStr.endsWith("'")) {
                    terminate(blockLineNumber, "Error: LETTER must be enclosed in single quotes ('A').");
                }
                if (valueStr.length() != 3) {
                    terminate(blockLineNumber, "Error: LETTER must contain exactly one character inside single quotes (e.g., 'A').");
                }
                variables.put(varName, valueStr.charAt(1));
                continue;
            }

            // Handle MESSAGE variable declarations
            if (line.startsWith("MESSAGE ")) {
                line = line.replace("MESSAGE", "").trim();
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("=");
                String varName = parts[0].trim();
                
                // Validate variable name syntax
                LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, blockLineNumber);
                if (!analyzer.validateVariableName(varName)) {
                    terminate(blockLineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                if (isDataTypeKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                }
                if (isReservedKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                
                if (parts.length < 2) {
                    variables.put(varName, "");
                    continue;
                }
                String valueStr = parts[1].trim();
                if (valueStr.startsWith("'") || valueStr.endsWith("'")) {
                    terminate(blockLineNumber, "Error: MESSAGE cannot use single quotes. Use double quotes for strings.");
                }
                if (!valueStr.startsWith("\"") && !valueStr.endsWith("\"") && !valueStr.contains("+")) {
                    terminate(blockLineNumber, "Error: MESSAGE must use double quotes or valid concatenation.");
                }
                String result = evaluateMessageExpression(valueStr, variables, blockLineNumber);
                variables.put(varName, result);
                continue;
            }

            // Handle BINARY variable declarations
            if (line.startsWith("BINARY ")) {
                line = line.replace("BINARY", "").trim();
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                
                String varName;
                String valueExpr = null;
                
                if (line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    varName = parts[0].trim();
                    valueExpr = parts[1].trim();
                } else {
                    varName = line.trim();
                }
                
                // Validate variable name syntax
                LexicalAnalyzer analyzer = new LexicalAnalyzer(varName, blockLineNumber);
                if (!analyzer.validateVariableName(varName)) {
                    terminate(blockLineNumber, "Error: Invalid variable name '" + varName + "'. Variable names must: start with letter or underscore, contain only alphanumeric characters and underscores, and cannot be keywords or contain special symbols.");
                }
                
                if (isDataTypeKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a data type keyword and cannot be used as a variable name.");
                }
                if (isReservedKeyword(varName)) {
                    terminate(blockLineNumber, "Error: '" + varName + "' is a reserved keyword and cannot be used as a variable name.");
                }
                // Enforce global uniqueness across all types
                
                if (valueExpr == null) {
                    variables.put(varName, "FALSE");
                    continue;
                }
                try {
                    boolean result = evaluateBinaryExpression(valueExpr, variables);
                    variables.put(varName, result ? "TRUE" : "FALSE");
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error: Invalid BINARY expression.");
                }
                continue;
            }

            // Handle increment/decrement statements inside blocks (x++; ++x; x--; --x;)
            if (line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*(\\+\\+|--)\\s*;?$")) {
                String varName = line.replace(";", "").trim();
                varName = varName.replaceAll("(\\+\\+|--)$", "").trim();
                if (!variables.containsKey(varName)) {
                    terminate(blockLineNumber, "Error: Variable '" + varName + "' not declared.");
                }
                Object current = variables.get(varName);
                boolean isIncrement = line.contains("++");
                if (current instanceof Integer) {
                    int v = (Integer) current;
                    variables.put(varName, isIncrement ? v + 1 : v - 1);
                } else if (current instanceof Double) {
                    double v = (Double) current;
                    variables.put(varName, isIncrement ? v + 1.0 : v - 1.0);
                } else {
                    terminate(blockLineNumber, "Error: Increment/Decrement allowed only for NUMBER or DECIMAL variables.");
                }
                continue;
            }

            if (line.matches("^(\\+\\+|--)\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*;?$")) {
                String cleaned = line.replace(";", "").trim();
                boolean isIncrement = cleaned.startsWith("++");
                String varName = cleaned.replaceFirst("^(\\+\\+|--)", "").trim();
                if (!variables.containsKey(varName)) {
                    terminate(blockLineNumber, "Error: Variable '" + varName + "' not declared.");
                }
                Object current = variables.get(varName);
                if (current instanceof Integer) {
                    int v = (Integer) current;
                    variables.put(varName, isIncrement ? v + 1 : v - 1);
                } else if (current instanceof Double) {
                    double v = (Double) current;
                    variables.put(varName, isIncrement ? v + 1.0 : v - 1.0);
                } else {
                    terminate(blockLineNumber, "Error: Increment/Decrement allowed only for NUMBER or DECIMAL variables.");
                }
                continue;
            }

            // Handle variable assignments (e.g., x = x + 1;)
            if (line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*=.*")) {
                // Remove semicolon from the end
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("=", 2);
                String varName = parts[0].trim();
                String valueExpr = parts[1].trim();

                if (!variables.containsKey(varName)) {
                    terminate(blockLineNumber, "Error: Variable '" + varName + "' not declared.");
                }

                Object oldValue = variables.get(varName);

                try {
                    if (oldValue instanceof Integer) {
                        double result = evaluateExpression(valueExpr, variables);
                        // Truncate decimal places (remove fractional part)
                        int truncatedValue = (int) result;
                        variables.put(varName, truncatedValue);
                    } else if (oldValue instanceof Double) {
                        double result = evaluateExpression(valueExpr, variables);
                        variables.put(varName, result);
                    } else if (oldValue instanceof Character) {
                        if (valueExpr.length() == 3 && valueExpr.startsWith("'") && valueExpr.endsWith("'")) {
                            variables.put(varName, valueExpr.charAt(1));
                        } else {
                            terminate(blockLineNumber, "Error: LETTER must be assigned using single quotes.");
                        }
                    } else if (oldValue instanceof String) {
                        // Check if it's a BINARY variable (stored as "TRUE" or "FALSE")
                        if (oldValue.equals("TRUE") || oldValue.equals("FALSE")) {
                            // It's a BINARY variable
                            if (valueExpr.equalsIgnoreCase("TRUE") || valueExpr.equalsIgnoreCase("FALSE")) {
                                variables.put(varName, valueExpr.toUpperCase());
                            } else {
                                terminate(blockLineNumber, "Error: Invalid value for BINARY variable.");
                            }
                        } else {
                            // It's a MESSAGE variable
                            if (valueExpr.startsWith("\"") && valueExpr.endsWith("\"")) {
                                String rawString = valueExpr.substring(1, valueExpr.length() - 1);
                                variables.put(varName, processEscapeSequences(rawString));
                            } else {
                                terminate(blockLineNumber, "Error: MESSAGE must be assigned using double quotes.");
                            }
                        }
                    }
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error assigning value to variable '" + varName + "'.");
                }
                continue;
            }

            // Handle SHOW statements
            if (line.startsWith("SHOW:")) {
                String payload = line.substring(5).trim();
                // Remove semicolon from the end
                if (payload.endsWith(";")) {
                    payload = payload.substring(0, payload.length() - 1).trim();
                }

                try {
                    if (payload.isEmpty()) {
                        // Empty SHOW statement
                        System.out.println();
                    } else if (payload.contains("@(")) {
                        // Handle variable interpolation with @(variableName) syntax
                        // Remove outer quotes if present
                        if (payload.startsWith("\"") && payload.endsWith("\"")) {
                            payload = payload.substring(1, payload.length() - 1);
                        }
                        String result = processVariableInterpolation(payload, variables);
                        System.out.println(result);
                    } else if (payload.startsWith("\"") && payload.endsWith("\"")) {
                        // Handle string literals with escape sequences
                        String stringValue = payload.substring(1, payload.length() - 1);
                        String processedValue = processEscapeSequences(stringValue);
                        System.out.println(processedValue);
                    } else if (payload.startsWith("(") && payload.endsWith(")")) {
                        // Handle boolean/comparison expressions wrapped in parentheses
                        String condition = payload.substring(1, payload.length() - 1).trim();
                        boolean result = evaluateBinaryExpression(condition, variables, blockLineNumber);
                        System.out.println(result ? "TRUE" : "FALSE");
                    } else if (isFunctionCall(payload)) {
                        // Handle function calls
                        try {
                            Object result = executeFunctionCall(payload, blockLineNumber);
                            System.out.println(result != null ? result.toString() : "");
                        } catch (Exception e) {
                            terminate(blockLineNumber, "Error: Function call failed → " + payload);
                        }
                    } else if (isArithmeticExpression(payload, variables)) {
                        // Handle arithmetic expressions (NUMBER/DECIMAL calculations)
                        double result = evaluateExpression(payload, variables, blockLineNumber);
                        // Check if result should be displayed as integer or decimal
                        if (result == (long) result) {
                            System.out.println((long) result);
                    } else {
                            System.out.println(result);
                        }
                    } else {
                        // Handle string concatenation using MESSAGE expression logic
                        String result = evaluateMessageExpression(payload, variables, blockLineNumber);
                        System.out.println(result);
                    }
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error: Invalid SHOW syntax or expression.");
                }
                continue;
            }

            // Handle RETURN statements
            if (line.startsWith("RETURN ")) {
                handleReturn(line, blockLineNumber);
                this.returnFlag = true;
                return; // Exit block execution
            }

            // Handle function calls
            if (isFunctionCall(line)) {
                try {
                    Object result = executeFunctionCall(line, blockLineNumber);
                    if (result != null) {
                        // If the function call is not part of an expression, we can store the result
                        // For now, we'll just execute the function (void functions won't return anything)
                    }
                } catch (Exception e) {
                    terminate(blockLineNumber, "Error executing function call: " + e.getMessage());
                }
                continue;
            }

            // Handle ASK statements (user input)
            if (line.contains("ASK:")) {
                if (line.endsWith(";")) {
                    line = line.substring(0, line.length() - 1).trim();
                }
                String[] parts = line.split("ASK:");
                if (parts.length < 2) {
                    terminate(blockLineNumber, "Error: Invalid ASK syntax.");
                }
                
                String varName = parts[0].trim();
                String message = parts[1].trim();
                
                // Remove quotes from message if present
                if (message.startsWith("\"") && message.endsWith("\"")) {
                    message = message.substring(1, message.length() - 1);
                }
                
                // Clean up variable name
                varName = varName.replaceAll("[^a-zA-Z0-9_]", "");
                
                if (!variables.containsKey(varName)) {
                    terminate(blockLineNumber, "Error: Variable '" + varName + "' not declared.");
                }
                
                // Display prompt message if provided
                if (!message.isEmpty()) {
                    System.out.print(message + " ");
                }
                
                Object currentValue = variables.get(varName);
                String input = scanner.nextLine();
                
                try {
                    if (currentValue instanceof Integer) {
                        variables.put(varName, Integer.parseInt(input));
                    } else if (currentValue instanceof Double) {
                        variables.put(varName, Double.parseDouble(input));
                    } else if (currentValue instanceof Character) {
                        if (input.length() == 1) {
                            variables.put(varName, input.charAt(0));
                        } else {
                            terminate(blockLineNumber, "Error: Invalid input for LETTER, only one character is allowed.");
                        }
                    } else if (currentValue instanceof String) {
                        // Check if it's a BINARY variable (stored as "TRUE" or "FALSE")
                        if (currentValue.equals("TRUE") || currentValue.equals("FALSE")) {
                            if (input.equalsIgnoreCase("TRUE") || input.equalsIgnoreCase("FALSE")) {
                                variables.put(varName, input.toUpperCase());
                            } else {
                                terminate(blockLineNumber, "Error: Invalid input for BINARY, must be TRUE or FALSE only.");
                            }
                        } else {
                            variables.put(varName, input);
                        }
                    }
                } catch (NumberFormatException e) {
                    terminate(blockLineNumber, "Error: Invalid input format for variable '" + varName + "'.");
                }
                continue;
            }

            // Handle CONTINUE statement
            if (line.equals("CONTINUE;")) {
                if (inLoop) {
                    continueFlag = true;
                    return;
                } else {
                    terminate(blockLineNumber, "Error: CONTINUE can only be used inside a loop.");
                }
            }

            // Handle BREAK statement
            if (line.equals("BREAK;")) {
                if (inLoop) {
                    breakFlag = true;
                    return;
                } else {
                    terminate(blockLineNumber, "Error: BREAK can only be used inside a loop.");
                }
            }
        }
    }


    /**
     * Skips lines until the next ELSE or block end (used for IF-ELSE chains)
     * @param br BufferedReader to read from
     * @throws IOException if reading fails
     */
    private void skipBlock(BufferedReader br) throws IOException {
        String temp;
        int braceCount = 0;

        while ((temp = br.readLine()) != null) {
            temp = temp.trim();
            if (temp.contains("{")) braceCount++;
            if (temp.contains("}")) {
                if (braceCount == 0) break;
                braceCount--;
            }
        }
    }


    /**
     * Evaluates arithmetic expressions with proper operator precedence
     * @param expr The expression to evaluate
     * @param variables Variable context for evaluation
     * @return The result of the expression
     */
    private double evaluateExpression(String expr, Map<String, Object> variables) {
        expr = expr.replaceAll("\\s+", "");

        // Replace variables with their values (word-boundary safe)
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String varName = entry.getKey();
            Object value = entry.getValue();
            // Use word boundaries to avoid partial replacements
            expr = expr.replaceAll("\\b" + Pattern.quote(varName) + "\\b", value.toString());
        }

        try {
            return evaluateArithmeticExpression(expr);
        } catch (Exception e) {
            terminate("Error: Undefined variable or invalid expression → " + expr);
            return 0; // unreachable, but keeps compiler happy
        }
    }
    
    /**
     * Evaluates a mathematical expression with variables (with line number for error reporting)
     * @param expr The expression to evaluate
     * @param variables The variable context
     * @param lineNumber The line number for error reporting
     * @return The result of the expression
     */
    private double evaluateExpression(String expr, Map<String, Object> variables, int lineNumber) {
        expr = expr.replaceAll("\\s+", "");

        // Handle function calls first
        if (isFunctionCall(expr)) {
            try {
                Object result = executeFunctionCall(expr, lineNumber);
                if (result instanceof Number) {
                    return ((Number) result).doubleValue();
                } else {
                    terminate(lineNumber, "Error: Function call returned non-numeric value → " + expr);
                }
            } catch (Exception e) {
                terminate(lineNumber, "Error: Function call failed in expression → " + expr);
            }
        }

        // Replace variables with their values (word-boundary safe)
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String varName = entry.getKey();
            Object value = entry.getValue();
            // Use word boundaries to avoid partial replacements
            expr = expr.replaceAll("\\b" + Pattern.quote(varName) + "\\b", value.toString());
        }

        try {
            return evaluateArithmeticExpression(expr, lineNumber);
        } catch (Exception e) {
            terminate(lineNumber, "Error: Undefined variable or invalid expression → " + expr);
            return 0; // unreachable, but keeps compiler happy
        }
    }
    
    /**
     * Evaluates arithmetic expressions with proper operator precedence
     * Handles parentheses, multiplication/division, and addition/subtraction
     * @param expr The arithmetic expression to evaluate
     * @return The result of the expression
     */
    private double evaluateArithmeticExpression(String expr) {
        // Remove all whitespace for easier parsing
        expr = expr.replaceAll("\\s+", "");
        
        // Handle parentheses first
        while (expr.contains("(") && expr.contains(")")) {
            int start = expr.lastIndexOf("(");
            int end = expr.indexOf(")", start);
            if (start == -1 || end == -1) break;
            
            String inner = expr.substring(start + 1, end);
            double result = evaluateArithmeticExpression(inner);
            expr = expr.substring(0, start) + result + expr.substring(end + 1);
        }
        
        // Handle multiplication, division, and modulo (left to right)
        while (expr.contains("*") || expr.contains("/") || expr.contains("%")) {
            int multIndex = expr.indexOf("*");
            int divIndex = expr.indexOf("/");
            int modIndex = expr.indexOf("%");
            
            int opIndex = -1;
            // Find the leftmost operator among *, /, %
            if (multIndex != -1) opIndex = multIndex;
            if (divIndex != -1 && (opIndex == -1 || divIndex < opIndex)) opIndex = divIndex;
            if (modIndex != -1 && (opIndex == -1 || modIndex < opIndex)) opIndex = modIndex;
            
            // Find the operands
            String left = findLeftOperand(expr, opIndex);
            String right = findRightOperand(expr, opIndex);
            
            double leftVal = Double.parseDouble(left);
            double rightVal = Double.parseDouble(right);
            double result;
            
            if (expr.charAt(opIndex) == '*') {
                result = leftVal * rightVal;
            } else if (expr.charAt(opIndex) == '/') {
                if (rightVal == 0) {
                    terminate("Error: Division by zero");
                }
                result = leftVal / rightVal;
            } else { // % operator
                if (rightVal == 0) {
                    terminate("Error: Modulo by zero");
                }
                result = leftVal % rightVal;
            }
            
            expr = expr.replace(left + expr.charAt(opIndex) + right, String.valueOf(result));
        }
        
        // Handle addition and subtraction (left to right)
        while (expr.contains("+") || (expr.contains("-") && !expr.startsWith("-"))) {
            int addIndex = expr.indexOf("+");
            int subIndex = findSubtractionIndex(expr);
            
            int opIndex = -1;
            if (addIndex != -1 && subIndex != -1) {
                opIndex = Math.min(addIndex, subIndex);
            } else if (addIndex != -1) {
                opIndex = addIndex;
            } else if (subIndex != -1) {
                opIndex = subIndex;
            } else {
                break;
            }
            
            // Find the operands
            String left = findLeftOperand(expr, opIndex);
            String right = findRightOperand(expr, opIndex);
            
            double leftVal = Double.parseDouble(left);
            double rightVal = Double.parseDouble(right);
            double result;
            
            if (expr.charAt(opIndex) == '+') {
                result = leftVal + rightVal;
            } else {
                result = leftVal - rightVal;
            }
            
            expr = expr.replace(left + expr.charAt(opIndex) + right, String.valueOf(result));
        }
        
        return Double.parseDouble(expr);
    }
    
    /**
     * Evaluates arithmetic expressions with proper line number error reporting
     * @param expr The arithmetic expression to evaluate
     * @param lineNumber The line number for error reporting
     * @return The result of the expression
     */
    private double evaluateArithmeticExpression(String expr, int lineNumber) {
        // Remove all whitespace for easier parsing
        expr = expr.replaceAll("\\s+", "");
        
        // Handle parentheses first
        while (expr.contains("(") && expr.contains(")")) {
            int start = expr.lastIndexOf("(");
            int end = expr.indexOf(")", start);
            if (start == -1 || end == -1) break;
            
            String inner = expr.substring(start + 1, end);
            double result = evaluateArithmeticExpression(inner, lineNumber);
            expr = expr.substring(0, start) + result + expr.substring(end + 1);
        }
        
        // Handle multiplication, division, and modulo (left to right)
        while (expr.contains("*") || expr.contains("/") || expr.contains("%")) {
            int multIndex = expr.indexOf("*");
            int divIndex = expr.indexOf("/");
            int modIndex = expr.indexOf("%");
            
            int opIndex = -1;
            // Find the leftmost operator among *, /, %
            if (multIndex != -1) opIndex = multIndex;
            if (divIndex != -1 && (opIndex == -1 || divIndex < opIndex)) opIndex = divIndex;
            if (modIndex != -1 && (opIndex == -1 || modIndex < opIndex)) opIndex = modIndex;
            
            // Find the operands
            String left = findLeftOperand(expr, opIndex);
            String right = findRightOperand(expr, opIndex);
            
            double leftVal = Double.parseDouble(left);
            double rightVal = Double.parseDouble(right);
            double result;
            
            if (expr.charAt(opIndex) == '*') {
                result = leftVal * rightVal;
            } else if (expr.charAt(opIndex) == '/') {
                if (rightVal == 0) {
                    terminate(lineNumber, "Error: Division by zero");
                }
                result = leftVal / rightVal;
            } else { // % operator
                if (rightVal == 0) {
                    terminate(lineNumber, "Error: Modulo by zero");
                }
                result = leftVal % rightVal;
            }
            
            expr = expr.replace(left + expr.charAt(opIndex) + right, String.valueOf(result));
        }
        
        // Handle addition and subtraction (left to right)
        while (expr.contains("+") || (expr.contains("-") && !expr.startsWith("-"))) {
            int addIndex = expr.indexOf("+");
            int subIndex = findSubtractionIndex(expr);
            
            int opIndex = -1;
            if (addIndex != -1 && subIndex != -1) {
                opIndex = Math.min(addIndex, subIndex);
            } else if (addIndex != -1) {
                opIndex = addIndex;
            } else if (subIndex != -1) {
                opIndex = subIndex;
            } else {
                break;
            }
            
            // Find the operands
            String left = findLeftOperand(expr, opIndex);
            String right = findRightOperand(expr, opIndex);
            
            double leftVal = Double.parseDouble(left);
            double rightVal = Double.parseDouble(right);
            double result;
            
            if (expr.charAt(opIndex) == '+') {
                result = leftVal + rightVal;
            } else {
                result = leftVal - rightVal;
            }
            
            expr = expr.replace(left + expr.charAt(opIndex) + right, String.valueOf(result));
        }
        
        return Double.parseDouble(expr);
    }
    
    private String findLeftOperand(String expr, int opIndex) {
        int start = opIndex - 1;
        while (start >= 0 && (Character.isDigit(expr.charAt(start)) || expr.charAt(start) == '.' || 
               (expr.charAt(start) == '-' && (start == 0 || !Character.isDigit(expr.charAt(start - 1)))))) {
            start--;
        }
        return expr.substring(start + 1, opIndex);
    }
    
    private String findRightOperand(String expr, int opIndex) {
        int end = opIndex + 1;
        
        // Handle negative numbers (e.g., "5+-10")
        if (end < expr.length() && expr.charAt(end) == '-') {
            end++; // Include the negative sign
        }
        
        // Extract digits and decimal point
        while (end < expr.length() && (Character.isDigit(expr.charAt(end)) || expr.charAt(end) == '.')) {
            end++;
        }
        return expr.substring(opIndex + 1, end);
    }
    
    private int findSubtractionIndex(String expr) {
        for (int i = 1; i < expr.length(); i++) {
            if (expr.charAt(i) == '-' && Character.isDigit(expr.charAt(i - 1))) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * Evaluates MESSAGE expressions (string concatenation)
     * @param expr The message expression to evaluate
     * @param variables Variable context for evaluation
     * @param lineNumber The line number for error reporting
     * @return The concatenated string result
     */
    private String evaluateMessageExpression(String expr, Map<String, Object> variables, int lineNumber) {
        expr = expr.trim();

        // Handle concatenation (e.g. "Hello" + name + "!")
        if (expr.contains("+")) {
            // Split on + but respect escape sequences
            List<String> parts = splitRespectingEscapes(expr, "+");
            StringBuilder sb = new StringBuilder();
            for (String part : parts) {
                part = part.trim();

                // String literal in double quotes
                if (part.startsWith("\"") && part.endsWith("\"")) {
                    String rawString = part.substring(1, part.length() - 1);
                    sb.append(processEscapeSequences(rawString));
                }
                // Variable reference
                else if (variables.containsKey(part)) {
                    Object value = variables.get(part);
                    sb.append(value != null ? value.toString() : "");
                }
                // Function call
                else if (isFunctionCall(part)) {
                    try {
                        Object result = executeFunctionCall(part, lineNumber);
                        sb.append(result != null ? result.toString() : "");
                    } catch (Exception e) {
                        terminate(lineNumber, "Error: Function call failed in expression → " + part);
                    }
                }
                // Empty or invalid
                else if (part.isEmpty()) {
                    continue;
                }
                else {
                    terminate(lineNumber, "Error: Invalid part in MESSAGE concatenation → " + part);
                }
            }
            return sb.toString();
        }

        // If it's just a single literal string
        if (expr.startsWith("\"") && expr.endsWith("\"")) {
            String rawString = expr.substring(1, expr.length() - 1);
            return processEscapeSequences(rawString);
        }

        // If it's a single variable
        if (variables.containsKey(expr)) {
            Object val = variables.get(expr);
            return val != null ? val.toString() : "";
        }

        // If it's a function call
        if (isFunctionCall(expr)) {
            try {
                Object result = executeFunctionCall(expr, lineNumber);
                return result != null ? result.toString() : "";
            } catch (Exception e) {
                terminate(lineNumber, "Error: Function call failed → " + expr);
            }
        }

        terminate(lineNumber, "Error: Invalid MESSAGE expression → " + expr);
        return "";
    }

    /**
     * Evaluates BINARY expressions (boolean logic)
     * @param expr The binary expression to evaluate
     * @param variables Variable context for evaluation
     * @return The boolean result
     */
    private boolean evaluateBinaryExpression(String expr, Map<String, Object> variables) {
        expr = expr.trim();
        
        // Check for Java-style symbols and reject them
        if (expr.contains("&&") || expr.contains("||") || expr.contains("!") ||
            expr.contains("==") || expr.contains("!=")) {
            terminate("Error: Use HumanLang keywords (EQUAL, NOT EQUAL, AND, OR, NOT) instead of symbols (==, !=, &&, ||, !). → " + expr);
        }

        // Handle direct TRUE/FALSE assignments
        if (expr.equalsIgnoreCase("TRUE")) {
            return true;
        } else if (expr.equalsIgnoreCase("FALSE")) {
            return false;
        }
        
        // Handle variable references
        if (variables.containsKey(expr)) {
            Object val = variables.get(expr);
            return val.toString().equalsIgnoreCase("TRUE");
        }
        
        // Handle numeric expressions (0 = false, nonzero = true)
        try {
            double val = evaluateExpression(expr, variables);
            return val != 0;
        } catch (Exception e) {
            // If it's not a numeric expression, try boolean expression evaluation
            return evaluateBooleanExpression(expr, variables);
        }
    }
    
    /**
     * Evaluates boolean expressions with proper line number error reporting
     * @param expr The boolean expression to evaluate
     * @param variables The variable context
     * @param lineNumber The line number for error reporting
     * @return The boolean result
     */
    private boolean evaluateBinaryExpression(String expr, Map<String, Object> variables, int lineNumber) {
        expr = expr.trim();
        
        // Check for Java-style symbols and reject them
        if (expr.contains("&&") || expr.contains("||") || expr.contains("!") ||
            expr.contains("==") || expr.contains("!=")) {
            terminate(lineNumber, "Error: Use HumanLang keywords (EQUAL, NOT EQUAL, AND, OR, NOT) instead of symbols (==, !=, &&, ||, !). → " + expr);
        }

        // Handle direct TRUE/FALSE assignments
        if (expr.equalsIgnoreCase("TRUE")) {
            return true;
        } else if (expr.equalsIgnoreCase("FALSE")) {
            return false;
        }
        
        // Handle variable references
        if (variables.containsKey(expr)) {
            Object val = variables.get(expr);
            return val.toString().equalsIgnoreCase("TRUE");
        }
        
        // Check if this is a comparison expression first
        if (expr.contains(">") || expr.contains("<") || expr.contains("==") || 
            expr.contains("!=") || expr.contains(">=") || expr.contains("<=") ||
            expr.contains(" EQUAL") || expr.contains("NOT EQUAL")) {
            // This is a comparison expression, evaluate as boolean
            return evaluateBooleanExpression(expr, variables, lineNumber);
        }
        
        // Handle numeric expressions (0 = false, nonzero = true)
        try {
            double val = evaluateExpression(expr, variables, lineNumber);
            return val != 0;
        } catch (Exception e) {
            // If it's not a numeric expression, try boolean expression evaluation
            return evaluateBooleanExpression(expr, variables, lineNumber);
        }
    }

    
    /**
     * Evaluates boolean expressions with HumanLang keywords
     * Supports AND, OR, NOT, EQUAL, NOT EQUAL, and comparison operators
     * @param expr The boolean expression to evaluate
     * @param variables Variable context for evaluation
     * @return The boolean result
     */
    private boolean evaluateBooleanExpression(String expr, Map<String, Object> variables) {
        expr = expr.trim();
        
        // Store original expression for error checking
        String originalExpr = expr;

        // Replace variable names with their actual values (word-boundary safe)
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String varName = entry.getKey();
            Object value = entry.getValue();
            expr = expr.replaceAll("\\b" + Pattern.quote(varName) + "\\b", value.toString());
        }
        
        // Check if original expression (before variable substitution) contains forbidden symbols
        if (originalExpr.contains("==") || originalExpr.contains("!=") || 
            originalExpr.contains("&&") || originalExpr.contains("||")) {
            terminate("Error: Use HumanLang keywords (EQUAL, NOT EQUAL, AND, OR) instead of symbols (==, !=, &&, ||). → " + originalExpr);
        }

        // --- Strict uppercase enforcement for logical keywords ---
        // Match these logical keywords (case-insensitive) including NOT EQUAL (two words).
        Pattern kwPattern = Pattern.compile("\\b(NOT\\s+EQUAL|AND|OR|NOT|TRUE|FALSE|EQUAL)\\b", Pattern.CASE_INSENSITIVE);
        Matcher kwMatcher = kwPattern.matcher(expr);
        while (kwMatcher.find()) {
            String found = kwMatcher.group();         // preserves original case/spaces
            // Normalize spaces inside found (for NOT EQUAL) and compare uppercase form
            String normalized = found.replaceAll("\\s+", " ").toUpperCase();
            // Accept only exact uppercase tokens with single space for multi-word token
            if (!found.equals(normalized)) {
                terminate("Error: Logical keywords must be UPPERCASE and spelled exactly as AND, OR, NOT, TRUE, FALSE, EQUAL, NOT EQUAL. → " + expr);
                return false; // unreachable because terminate exits, but keeps compiler happy
            }
        }

        // Convert textual EQUAL/NOT EQUAL into symbols for easier parsing
        // (we already ensured the keywords, if present, are uppercase)
        expr = expr.replaceAll("\\bNOT\\s+EQUAL\\b", "!=");
        expr = expr.replaceAll("\\bEQUAL\\b", "==");
        // Keep uppercase TRUE/FALSE as-is; numeric comparisons handled below.

        // Handle NOT (unary)
        if (expr.startsWith("NOT ")) {
            String inner = expr.substring(4).trim();
            return !evaluateBooleanExpression(inner, variables);
        }

        // Parentheses
        if (expr.startsWith("(") && expr.endsWith(")")) {
            return evaluateBooleanExpression(expr.substring(1, expr.length() - 1), variables);
        }

        // AND / OR (textual)
        if (expr.contains(" AND ")) {
            String[] parts = expr.split("\\s+AND\\s+", 2);
            return evaluateBooleanExpression(parts[0], variables) && evaluateBooleanExpression(parts[1], variables);
        }
        if (expr.contains(" OR ")) {
            String[] parts = expr.split("\\s+OR\\s+", 2);
            return evaluateBooleanExpression(parts[0], variables) || evaluateBooleanExpression(parts[1], variables);
        }

        // Comparison operators (check multi-char ops first)
            if (expr.contains(">=")) {
                String[] parts = expr.split(">=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), ">=");
            } else if (expr.contains("<=")) {
                String[] parts = expr.split("<=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "<=");
            } else if (expr.contains("==")) {
                String[] parts = expr.split("==", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "==");
            } else if (expr.contains("!=")) {
                String[] parts = expr.split("!=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "!=");
            } else if (expr.contains(">")) {
                String[] parts = expr.split(">", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), ">");
            } else if (expr.contains("<")) {
                String[] parts = expr.split("<", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "<");
        }

        // Single boolean literal
        if (expr.equals("TRUE")) return true;
        if (expr.equals("FALSE")) return false;

        // If we get here, it's not a recognized boolean expression
        terminate("Error: Invalid boolean expression → " + expr);
        return false;
    }


    /**
     * Compares two values (numeric or boolean) using the specified operator
     * @param left Left operand
     * @param right Right operand
     * @param operator Comparison operator (==, !=, <, >, <=, >=)
     * @return The result of the comparison
     */
    private boolean compareValues(String left, String right, String operator) {
        // Check if both are boolean values (TRUE/FALSE)
        if ((left.equals("TRUE") || left.equals("FALSE")) && 
            (right.equals("TRUE") || right.equals("FALSE"))) {
            boolean leftBool = left.equals("TRUE");
            boolean rightBool = right.equals("TRUE");
            
            switch (operator) {
                case "==":
                    return leftBool == rightBool;
                case "!=":
                    return leftBool != rightBool;
                default:
                    terminate("Error: Cannot use operator '" + operator + "' with boolean values");
                    return false;
            }
        }
        
        // Check if both are string values (for EQUAL comparison)
        if (operator.equals("==") || operator.equals("!=")) {
            // For equality operators, we can compare strings
            switch (operator) {
                case "==":
                    return left.equals(right);
                case "!=":
                    return !left.equals(right);
            }
        }
        
        // Otherwise, treat as numeric comparison
        try {
            // Evaluate arithmetic expressions if they contain operators
            double leftNum;
            double rightNum;
            
            // Try to evaluate as arithmetic expression first (handles %, *, /, +, -)
            try {
                leftNum = evaluateArithmeticExpression(left);
            } catch (Exception e) {
                // If not an expression, try to parse as a number
                leftNum = Double.parseDouble(left);
            }
            
            try {
                rightNum = evaluateArithmeticExpression(right);
            } catch (Exception e) {
                // If not an expression, try to parse as a number
                rightNum = Double.parseDouble(right);
            }
            
            switch (operator) {
                case "==":
                    return leftNum == rightNum;
                case "!=":
                    return leftNum != rightNum;
                case "<":
                    return leftNum < rightNum;
                case ">":
                    return leftNum > rightNum;
                case "<=":
                    return leftNum <= rightNum;
                case ">=":
                    return leftNum >= rightNum;
                default:
                    terminate("Error: Unknown comparison operator: " + operator);
                    return false;
            }
        } catch (NumberFormatException e) {
            terminate("Error: Cannot compare non-numeric values: '" + left + "' and '" + right + "'");
            return false;
        }
    }
    
    /**
     * Evaluates boolean expressions with proper line number error reporting
     * @param expr The boolean expression to evaluate
     * @param variables The variable context
     * @param lineNumber The line number for error reporting
     * @return The boolean result
     */
    private boolean evaluateBooleanExpression(String expr, Map<String, Object> variables, int lineNumber) {
        expr = expr.trim();
        
        // Store original expression for error checking
        String originalExpr = expr;

        // Replace variable names with their actual values (word-boundary safe)
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String varName = entry.getKey();
            Object value = entry.getValue();
            expr = expr.replaceAll("\\b" + Pattern.quote(varName) + "\\b", value.toString());
        }
        
        // Check if original expression (before variable substitution) contains forbidden symbols
        if (originalExpr.contains("==") || originalExpr.contains("!=") || 
            originalExpr.contains("&&") || originalExpr.contains("||")) {
            terminate(lineNumber, "Error: Use HumanLang keywords (EQUAL, NOT EQUAL, AND, OR) instead of symbols (==, !=, &&, ||). → " + originalExpr);
        }

        // --- Strict uppercase enforcement for logical keywords ---
        // Match these logical keywords (case-insensitive) including NOT EQUAL (two words).
        Pattern kwPattern = Pattern.compile("\\b(NOT\\s+EQUAL|AND|OR|NOT|TRUE|FALSE|EQUAL)\\b", Pattern.CASE_INSENSITIVE);
        Matcher kwMatcher = kwPattern.matcher(expr);
        while (kwMatcher.find()) {
            String found = kwMatcher.group();         // preserves original case/spaces
            // Normalize spaces inside found (for NOT EQUAL) and compare uppercase form
            String normalized = found.replaceAll("\\s+", " ").toUpperCase();
            // Accept only exact uppercase tokens with single space for multi-word token
            if (!found.equals(normalized)) {
                terminate(lineNumber, "Error: Logical keywords must be UPPERCASE and spelled exactly as AND, OR, NOT, TRUE, FALSE, EQUAL, NOT EQUAL. → " + expr);
                return false; // unreachable because terminate exits, but keeps compiler happy
            }
        }

        // Convert textual EQUAL/NOT EQUAL into symbols for easier parsing
        // (we already ensured the keywords, if present, are uppercase)
        expr = expr.replaceAll("\\bNOT\\s+EQUAL\\b", "!=");
        expr = expr.replaceAll("\\bEQUAL\\b", "==");
        // Keep uppercase TRUE/FALSE as-is; numeric comparisons handled below.

        // Handle NOT (unary)
        if (expr.startsWith("NOT ")) {
            String inner = expr.substring(4).trim();
            return !evaluateBooleanExpression(inner, variables, lineNumber);
        }

        // Parentheses
        if (expr.startsWith("(") && expr.endsWith(")")) {
            return evaluateBooleanExpression(expr.substring(1, expr.length() - 1), variables, lineNumber);
        }

        // AND / OR (textual)
        if (expr.contains(" AND ")) {
            String[] parts = expr.split("\\s+AND\\s+", 2);
            return evaluateBooleanExpression(parts[0], variables, lineNumber) && evaluateBooleanExpression(parts[1], variables, lineNumber);
        }
        if (expr.contains(" OR ")) {
            String[] parts = expr.split("\\s+OR\\s+", 2);
            return evaluateBooleanExpression(parts[0], variables, lineNumber) || evaluateBooleanExpression(parts[1], variables, lineNumber);
        }

        // Comparison operators (check multi-char ops first)
            if (expr.contains(">=")) {
                String[] parts = expr.split(">=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), ">=", lineNumber);
            } else if (expr.contains("<=")) {
                String[] parts = expr.split("<=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "<=", lineNumber);
            } else if (expr.contains("==")) {
                String[] parts = expr.split("==", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "==", lineNumber);
            } else if (expr.contains("!=")) {
                String[] parts = expr.split("!=", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "!=", lineNumber);
            } else if (expr.contains(">")) {
                String[] parts = expr.split(">", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), ">", lineNumber);
            } else if (expr.contains("<")) {
                String[] parts = expr.split("<", 2);
            return compareValues(parts[0].trim(), parts[1].trim(), "<", lineNumber);
        }

        // Single boolean literal
        if (expr.equals("TRUE")) return true;
        if (expr.equals("FALSE")) return false;

        // If we get here, it's not a recognized boolean expression
        terminate(lineNumber, "Error: Invalid boolean expression → " + expr);
        return false;
    }
    
    /**
     * Compares two values with proper line number error reporting
     * @param left The left operand
     * @param right The right operand
     * @param operator The comparison operator
     * @param lineNumber The line number for error reporting
     * @return The comparison result
     */
    private boolean compareValues(String left, String right, String operator, int lineNumber) {
        // Check if both are boolean values (TRUE/FALSE)
        if ((left.equals("TRUE") || left.equals("FALSE")) && 
            (right.equals("TRUE") || right.equals("FALSE"))) {
            boolean leftBool = left.equals("TRUE");
            boolean rightBool = right.equals("TRUE");
            
            switch (operator) {
                case "==":
                    return leftBool == rightBool;
                case "!=":
                    return leftBool != rightBool;
                default:
                    terminate(lineNumber, "Error: Cannot use operator '" + operator + "' with boolean values");
                    return false;
            }
        }
        
        // Check if both are string values (for EQUAL comparison)
        if (operator.equals("==") || operator.equals("!=")) {
            // For equality operators, we can compare strings
            switch (operator) {
                case "==":
                    return left.equals(right);
                case "!=":
                    return !left.equals(right);
            }
        }
        
        // Otherwise, treat as numeric comparison
        try {
            // Evaluate arithmetic expressions if they contain operators
            double leftNum;
            double rightNum;
            
            // Try to evaluate as arithmetic expression first (handles %, *, /, +, -)
            try {
                leftNum = evaluateArithmeticExpression(left, lineNumber);
            } catch (Exception e) {
                // If not an expression, try to parse as a number
                leftNum = Double.parseDouble(left);
            }
            
            try {
                rightNum = evaluateArithmeticExpression(right, lineNumber);
            } catch (Exception e) {
                // If not an expression, try to parse as a number
                rightNum = Double.parseDouble(right);
            }
            
            switch (operator) {
                case "==":
                    return leftNum == rightNum;
                case "!=":
                    return leftNum != rightNum;
                case "<":
                    return leftNum < rightNum;
                case ">":
                    return leftNum > rightNum;
                case "<=":
                    return leftNum <= rightNum;
                case ">=":
                    return leftNum >= rightNum;
                default:
                    terminate(lineNumber, "Error: Unknown comparison operator: " + operator);
                    return false;
            }
        } catch (NumberFormatException e) {
            terminate(lineNumber, "Error: Cannot compare non-numeric values: '" + left + "' and '" + right + "'");
            return false;
        }
    }

    /**
     * Terminates the program with an error message
     * @param message The error message to display
     */
    private void terminate(String message) {
        System.out.println(message);
        System.exit(0);
    }
    
    /**
     * Terminates the program with an error message including line number
     * @param lineNumber The line number where the error occurred
     * @param message The error message to display
     */
    private void terminate(int lineNumber, String message) {
        System.out.println("Line " + lineNumber + ": " + message);
        System.exit(0);
    }

    /**
     * Helper method to convert stored variable values into a clean printable string
     * @param val The value to format
     * @return The formatted string representation
     */
    private String formatValue(Object val) {
        if (val == null) return "null";
        if (val instanceof Integer) return Integer.toString((Integer) val);
        if (val instanceof Double) {
            double d = (Double) val;
            // Always show .0 for DECIMAL values to distinguish from NUMBER
            return String.format("%.1f", d);
        }
        if (val instanceof Boolean) return val.toString();
        if (val instanceof Character) return val.toString();
        // fallback for String or other types
        return val.toString();
    }

    /**
     * Splits a string on a delimiter while respecting escape sequences
     * @param str The string to split
     * @param delimiter The delimiter to split on
     * @return List of parts after splitting
     */
    private List<String> splitRespectingEscapes(String str, String delimiter) {
        List<String> parts = new ArrayList<>();
        StringBuilder currentPart = new StringBuilder();
        
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            
            // Check if we found the delimiter
            if (i + delimiter.length() <= str.length()) {
                String substr = str.substring(i, i + delimiter.length());
                if (substr.equals(delimiter)) {
                    // Check if it's escaped
                    if (i > 0 && str.charAt(i - 1) == '\\') {
                        // It's escaped, treat as literal
                        currentPart.append(ch);
                        continue;
                    } else {
                        // It's a real delimiter, split here
                        parts.add(currentPart.toString());
                        currentPart.setLength(0);
                        i += delimiter.length() - 1; // Skip the delimiter
                        continue;
                    }
                }
            }
            
            currentPart.append(ch);
        }
        
        // Add the last part
        parts.add(currentPart.toString());
        return parts;
    }

    /**
     * Processes escape sequences in string literals
     * Converts \", \\, \n, \t, \+ to their actual characters
     * @param str The string with escape sequences
     * @return The string with escape sequences processed
     */
    private String processEscapeSequences(String str) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (ch == '\\' && i + 1 < str.length()) {
                char nextChar = str.charAt(i + 1);
                switch (nextChar) {
                    case '"':
                        result.append('"');
                        i++; // Skip the next character
                        break;
                    case '\\':
                        result.append('\\');
                        i++; // Skip the next character
                        break;
                    case 'n':
                        result.append('\n');
                        i++; // Skip the next character
                        break;
                    case 't':
                        result.append('\t');
                        i++; // Skip the next character
                        break;
                    case 'r':
                        result.append('\r');
                        i++; // Skip the next character
                        break;
                    case '+':
                        result.append('+');
                        i++; // Skip the next character
                        break;
                    default:
                        // Unknown escape sequence, keep the backslash
                        result.append(ch);
                        break;
                }
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    /**
     * Processes variable interpolation using @(variableName) syntax in SHOW statements
     * @param payload The SHOW payload containing @(variable) expressions
     * @param variables The variable context
     * @return The processed string with variables interpolated
     */
    private String processVariableInterpolation(String payload, Map<String, Object> variables) {
        StringBuilder result = new StringBuilder();
        int i = 0;
        
        while (i < payload.length()) {
            char currentChar = payload.charAt(i);
            
            // Check for @( pattern for variable interpolation
            if (currentChar == '@' && i + 1 < payload.length() && payload.charAt(i + 1) == '(') {
                // Found @( pattern, extract variable name
                i += 2; // Move past @(
                StringBuilder varName = new StringBuilder();
                
                // Extract variable name until we hit )
                while (i < payload.length() && payload.charAt(i) != ')') {
                    varName.append(payload.charAt(i));
                    i++;
                }
                
                // Check if we found the closing )
                if (i >= payload.length()) {
                    // No closing ), treat as literal text
                    result.append("@(").append(varName.toString());
                } else {
                    // Found closing ), process the variable
                    i++; // Move past )
                    String variableName = varName.toString().trim();
                    
                    if (variables.containsKey(variableName)) {
                        // Variable exists, interpolate it
                        result.append(formatValue(variables.get(variableName)));
                    } else {
                        // Variable doesn't exist, print @(variableName) as is
                        result.append("@(").append(variableName).append(")");
                    }
                }
            } else {
                // Regular character or @ without (, just append it
                result.append(currentChar);
                i++;
            }
        }
        
        return result.toString();
    }

    /**
     * Extracts condition from IF/ELSE IF statements
     * @param line The line containing the condition
     * @return The extracted condition string
     */
    private String extractCondition(String line) {
        int firstBracket = line.indexOf("[");
        int lastBracket = line.lastIndexOf("]");
        if (firstBracket == -1 || lastBracket == -1 || firstBracket == lastBracket) {
            terminate("Error: Invalid condition format → " + line);
        }
        return line.substring(firstBracket + 1, lastBracket).trim();
    }
    
    /**
     * Extracts condition from IF/ELSE IF statements with line number error reporting
     * @param line The line containing the condition
     * @param lineNumber The line number for error reporting
     * @return The extracted condition string
     */
    private String extractCondition(String line, int lineNumber) {
        int firstBracket = line.indexOf("[");
        int lastBracket = line.lastIndexOf("]");
        if (firstBracket == -1 || lastBracket == -1 || firstBracket == lastBracket) {
            terminate(lineNumber, "Error: Invalid condition format → " + line);
        }
        return line.substring(firstBracket + 1, lastBracket).trim();
    }
    

    /**
     * Determines if an expression is a boolean/comparison expression
     * @param expr The expression to check
     * @return true if it contains boolean/comparison operators
     */
    private boolean isBooleanExpression(String expr) {
        return expr.contains("EQUAL") || expr.contains("NOT") || 
               expr.contains("LESS") || expr.contains("GREATER") || 
               expr.contains("AND") || expr.contains("OR");
    }
    
    /**
     * Determines if an expression is an arithmetic expression (numbers and operators)
     * vs a string concatenation expression
     * @param expr The expression to check
     * @param variables The variable context
     * @return true if it's an arithmetic expression, false if it's string concatenation
     */
    private boolean isArithmeticExpression(String expr, Map<String, Object> variables) {
        // Remove spaces for easier analysis
        String cleaned = expr.trim();
        
        // If it contains quotes, it's likely string concatenation
        if (cleaned.contains("\"")) {
            return false;
        }
        
        // If it contains comparison operators without arithmetic operators, it's a boolean expression
        if ((cleaned.contains("EQUAL") || cleaned.contains("LESS") || cleaned.contains("GREATER") || 
             cleaned.contains("NOT")) && 
            !cleaned.contains("+") && !cleaned.contains("-") && !cleaned.contains("*") && 
            !cleaned.contains("/") && !cleaned.contains("%")) {
            return false;
        }
        
        // Check if expression contains only numbers, variables, arithmetic operators, and whitespace
        // Split by arithmetic operators and check each part
        String[] parts = cleaned.split("[+\\-*/%()]");
        
        for (String part : parts) {
            part = part.trim();
            if (part.isEmpty()) continue;
            
            // Check if it's a number (integer or decimal)
            if (part.matches("-?\\d+(\\.\\d+)?")) {
                continue; // It's a number
            }
            
            // Check if it's a variable
            if (variables.containsKey(part)) {
                Object value = variables.get(part);
                // If variable is a NUMBER or DECIMAL, it's arithmetic
                if (value instanceof Integer || value instanceof Double) {
                    continue;
                } else {
                    // If variable is MESSAGE/LETTER, it's not arithmetic
                    return false;
                }
            } else {
                // Unknown part, not arithmetic
                return false;
            }
        }
        
        // If we get here and the expression contains arithmetic operators, it's arithmetic
        return cleaned.contains("+") || cleaned.contains("-") || cleaned.contains("*") ||
               cleaned.contains("/") || cleaned.contains("%");
    }

    /**
     * Executes a SELECT (switch) block with WHEN and DEFAULT clauses.
     * Syntax example:
     * SELECT [expr] THEN {
     *     WHEN "a":
     *         SHOW: "Hello a";
     *     WHEN "b":
     *         SHOW: "Hello b";
     *     DEFAULT:
     *         SHOW: "NO MATCH";
     * }
     */
    private void executeSelectBlock(String selectorExpr, String block, Map<String, Object> variables, int lineNumber) {
        // Evaluate selector expression to a string (preserve numbers and text as string for equality)
        String selectorValue = evaluateSelectValue(selectorExpr, variables, lineNumber);

        // Parse WHEN/DEFAULT entries
        String[] rawLines = block.split("\n");
        StringBuilder currentCaseBlock = null;
        String currentCaseLabel = null; // null means DEFAULT
        Map<String, StringBuilder> labelToBlock = new HashMap<>();
        StringBuilder defaultBlock = null;

        for (int i = 0; i < rawLines.length; i++) {
            String raw = rawLines[i];
            String ln = raw.trim();

            if (ln.isEmpty()) {
                if (currentCaseBlock != null) currentCaseBlock.append(raw).append('\n');
                continue;
            }

            if (ln.startsWith("WHEN ")) {
                // Finish previous case
                if (currentCaseBlock != null) {
                    if (currentCaseLabel == null) {
                        defaultBlock = currentCaseBlock;
                    } else {
                        labelToBlock.put(currentCaseLabel, currentCaseBlock);
                    }
                }

                int colonIdx = ln.indexOf(":");
                if (colonIdx == -1) {
                    terminate(lineNumber, "Error: Missing ':' after WHEN label → " + ln);
                }
                String labelPart = ln.substring(5, colonIdx).trim();
                String normalizedLabel = evaluateSelectValue(labelPart, variables, lineNumber);
                currentCaseLabel = normalizedLabel;
                currentCaseBlock = new StringBuilder();
                // Remainder after ':' on same line goes into block
                String after = ln.substring(colonIdx + 1).trim();
                if (!after.isEmpty()) currentCaseBlock.append(after).append('\n');
            } else if (ln.startsWith("DEFAULT")) {
                // Finish previous case
                if (currentCaseBlock != null) {
                    if (currentCaseLabel == null) {
                        defaultBlock = currentCaseBlock;
                    } else {
                        labelToBlock.put(currentCaseLabel, currentCaseBlock);
                    }
                }
                currentCaseLabel = null; // mark as DEFAULT
                currentCaseBlock = new StringBuilder();
                int colonIdx = ln.indexOf(":");
                if (colonIdx == -1) {
                    terminate(lineNumber, "Error: Missing ':' after DEFAULT → " + ln);
                }
                String after = ln.substring(colonIdx + 1).trim();
                if (!after.isEmpty()) currentCaseBlock.append(after).append('\n');
            } else {
                // Regular line inside the current WHEN/DEFAULT block
                if (currentCaseBlock == null) {
                    // Allow stray lines (skip) or treat as error; choose to skip
                    continue;
                }
                currentCaseBlock.append(raw).append('\n');
            }
        }

        // Store the last accumulated block
        if (currentCaseBlock != null) {
            if (currentCaseLabel == null) {
                defaultBlock = currentCaseBlock;
            } else {
                labelToBlock.put(currentCaseLabel, currentCaseBlock);
            }
        }

        // Execute matched WHEN, otherwise DEFAULT
        StringBuilder matched = labelToBlock.get(selectorValue);
        if (matched == null) {
            // Try loose match: numbers vs strings that represent same number
            for (Map.Entry<String, StringBuilder> e : labelToBlock.entrySet()) {
                if (equalsAsHuman(selectorValue, e.getKey())) {
                    matched = e.getValue();
                    break;
                }
            }
        }

        if (matched != null) {
            executeCode(matched.toString());
        } else if (defaultBlock != null) {
            executeCode(defaultBlock.toString());
        }
    }

    private boolean equalsAsHuman(String a, String b) {
        if (a.equals(b)) return true;
        try {
            double da = Double.parseDouble(a);
            double db = Double.parseDouble(b);
            return da == db;
        } catch (Exception ignored) { }
        return false;
    }

    private String evaluateSelectValue(String expr, Map<String, Object> variables, int lineNumber) {
        String trimmed = expr.trim();
        // If a quoted string, unquote and process escapes
        if (trimmed.startsWith("\"") && trimmed.endsWith("\"")) {
            String inside = trimmed.substring(1, trimmed.length() - 1);
            return processEscapeSequences(inside);
        }
        // If it's a variable
        if (variables.containsKey(trimmed)) {
            Object v = variables.get(trimmed);
            return formatValue(v);
        }
        // Try boolean expression → TRUE/FALSE
        try {
            boolean b = evaluateBinaryExpression(trimmed, variables, lineNumber);
            return b ? "TRUE" : "FALSE";
        } catch (Exception ignored) {}
        // Try arithmetic expression → number string
        try {
            double d = evaluateExpression(trimmed, variables, lineNumber);
            if (d == (long)d) return Long.toString((long)d);
            return Double.toString(d);
        } catch (Exception ignored) {}
        // Fallback return raw token
        return trimmed;
    }

    /**
    * Ensure that a variable is not already declared (regardless of type).
    * Throws error if variable already exists under any type.
    */
    
    /**
     * Pre-parses the source code to find and register all TASK definitions.
     * @param lines Array of code lines.
     */
    void parseFunctionDefinitions(String[] lines) {
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i].trim();
            if (line.startsWith("TASK") || (line.split(" ").length > 1 && DATA_TYPES.contains(line.split(" ")[0]) && line.split(" ")[1].equals("TASK"))) {
                FunctionDefinition funcDef = new FunctionDefinition();
                funcDef.startLine = i + 1;

                // Extract return type, name
                String signature = line.substring(0, line.indexOf("DO {")).trim();
                String[] sigParts = signature.split("\\s+with\\s+");
                String nameAndTypePart = sigParts[0];

                String[] nameParts = nameAndTypePart.split("\\s+");
                if (DATA_TYPES.contains(nameParts[0])) {
                    funcDef.returnType = nameParts[0];
                    funcDef.name = nameParts[2];
                } else {
                    funcDef.returnType = null; // void
                    funcDef.name = nameParts[1];
                }

                // Extract parameters if they exist
                if (sigParts.length > 1) {
                    String paramsPart = sigParts[1];
                    String[] params = paramsPart.split(",");
                    for (String p : params) {
                        p = p.trim();
                        String[] paramTokens = p.split("\\s+");
                        if (paramTokens.length == 2) {
                            String paramType = paramTokens[0];
                            String paramName = paramTokens[1];
                            if (!DATA_TYPES.contains(paramType)) {
                                terminate(funcDef.startLine, "Error: Unknown parameter type '" + paramType + "' in function '" + funcDef.name + "'.");
                            }
                            funcDef.parameters.add(new Parameter(paramType, paramName));
                        } else {
                             terminate(funcDef.startLine, "Error: Invalid parameter format '" + p + "' in function '" + funcDef.name + "'.");
                        }
                    }
                }

                // Extract body
                StringBuilder bodyBuilder = new StringBuilder();
                int braceCount = 1;
                i++; // Move to the line after the function signature
                while (i < lines.length && braceCount > 0) {
                    String bodyLine = lines[i];
                    if (bodyLine.contains("{")) braceCount += countOccurrences(bodyLine, '{');
                    if (bodyLine.contains("}")) braceCount -= countOccurrences(bodyLine, '}');
                    if (braceCount > 0) {
                        bodyBuilder.append(bodyLine).append("\n");
                    }
                    i++;
                }
                i--; // Adjust index for outer loop

                funcDef.body = bodyBuilder.toString();
                functions.put(funcDef.name, funcDef);
            }
        }
    }

    private static int countOccurrences(String str, char ch) {
        return (int) str.chars().filter(c -> c == ch).count();
    }
    
    /**
     * Skips a TASK block by finding the matching closing brace
     * @param lines Array of all lines
     * @param startIndex Index of the TASK line
     * @return Index after the closing brace
     */
    private int skipTASKBlock(String[] lines, int startIndex) {
        int braceCount = 1; // Start with 1 for the opening brace
        int i = startIndex;
        
        while (i < lines.length && braceCount > 0) {
            i++;
            if (i >= lines.length) break;
            
            String currentLine = lines[i].trim();
            
            // Count opening and closing braces
            for (char c : currentLine.toCharArray()) {
                if (c == '{') braceCount++;
                else if (c == '}') braceCount--;
            }
        }
        
        return i; // Return index after the closing brace
    }
    
    /**
     * Checks if a line looks like a function call.
     * @param line The line to check.
     * @return true if it's a potential function call.
     */
    private boolean isFunctionCall(String line) {
        line = line.trim();
        
        // Must contain parentheses
        if (!line.contains("(") || !line.contains(")")) {
            return false;
        }
        
        // Must start with a valid identifier
        if (!line.matches("^[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(.*\\).*")) {
            return false;
        }
        
        // Must not be a control structure
        if (line.startsWith("IF") || line.startsWith("WHILE") || line.startsWith("SHOW") || 
            line.startsWith("NUMBER") || line.startsWith("MESSAGE") || line.startsWith("DECIMAL") ||
            line.startsWith("LETTER") || line.startsWith("BINARY")) {
            return false;
        }
        
        // Check if it's a known function
        int openParen = line.indexOf('(');
        String functionName = line.substring(0, openParen).trim();
        return functions.containsKey(functionName);
    }
    
    /**
     * Executes a function call by finding the function definition and executing it with parameters
     * @param line The function call line
     * @param lineNumber The line number for error reporting
     * @return The return value of the function, or null for void functions
     */
    private Object executeFunctionCall(String line, int lineNumber) {
        // Parse function name and arguments
        int openParen = line.indexOf('(');
        int closeParen = line.lastIndexOf(')');
        
        if (openParen == -1 || closeParen == -1) {
            terminate(lineNumber, "Error: Invalid function call syntax → " + line);
        }
        
        String functionName = line.substring(0, openParen).trim();
        String argsString = line.substring(openParen + 1, closeParen).trim();
        
        // Find the function definition
        FunctionDefinition funcDef = functions.get(functionName);
        if (funcDef == null) {
            terminate(lineNumber, "Error: Function '" + functionName + "' not found");
        }
        
        // Parse arguments
        List<Object> arguments = parseFunctionArguments(argsString, lineNumber);
        
        // Check argument count
        if (arguments.size() != funcDef.parameters.size()) {
            terminate(lineNumber, "Error: Function '" + functionName + "' expects " + 
                     funcDef.parameters.size() + " arguments, but got " + arguments.size());
        }
        
        // Create new variable scope for function execution
        Map<String, Object> functionVariables = new HashMap<>();
        
        // Set parameter values
        for (int i = 0; i < funcDef.parameters.size(); i++) {
            Parameter param = funcDef.parameters.get(i);
            Object argValue = arguments.get(i);
            
            // Type checking
            if (!isCompatibleType(argValue, param.type)) {
                terminate(lineNumber, "Error: Type mismatch for parameter '" + param.name + 
                         "'. Expected " + param.type + ", got " + getTypeName(argValue));
            }
            
            functionVariables.put(param.name, argValue);
        }
        
        // Execute function body
        Interpreter functionInterpreter = new Interpreter();
        functionInterpreter.variables = functionVariables;
        functionInterpreter.executeBlockInternal(funcDef.body);
        
        // Return the result
        return functionInterpreter.returnValue;
    }
    
    /**
     * Parses function arguments from a string
     * @param argsString The arguments string
     * @param lineNumber The line number for error reporting
     * @return List of parsed argument values
     */
    private List<Object> parseFunctionArguments(String argsString, int lineNumber) {
        List<Object> arguments = new ArrayList<>();
        
        if (argsString.trim().isEmpty()) {
            return arguments; // No arguments
        }
        
        // Simple argument parsing - split by comma and evaluate each
        String[] argStrings = argsString.split(",");
        for (String arg : argStrings) {
            arg = arg.trim();
            if (arg.isEmpty()) continue;
            
            // Remove quotes if it's a string literal
            if (arg.startsWith("\"") && arg.endsWith("\"")) {
                arguments.add(arg.substring(1, arg.length() - 1));
            } else if (arg.matches("^\\d+$")) {
                // Integer
                arguments.add(Integer.parseInt(arg));
            } else if (arg.matches("^\\d+\\.\\d+$")) {
                // Decimal
                arguments.add(Double.parseDouble(arg));
            } else if (variables.containsKey(arg)) {
                // Variable reference
                arguments.add(variables.get(arg));
            } else {
                // Try to evaluate as expression
                try {
                    double result = evaluateExpression(arg, variables, lineNumber);
                    arguments.add(result);
                } catch (Exception e) {
                    terminate(lineNumber, "Error: Invalid argument '" + arg + "'");
                }
            }
        }
        
        return arguments;
    }
    
    /**
     * Checks if a value is compatible with a given type
     * @param value The value to check
     * @param type The expected type
     * @return true if compatible
     */
    private boolean isCompatibleType(Object value, String type) {
        if (value == null) return true; // null is compatible with any type
        
        switch (type.toUpperCase()) {
            case "NUMBER":
                return value instanceof Integer || value instanceof Double;
            case "DECIMAL":
                return value instanceof Double;
            case "MESSAGE":
            case "LETTER":
                return value instanceof String;
            case "BINARY":
                return value instanceof Boolean;
            default:
                return false;
        }
    }
    
    /**
     * Gets the type name of a value
     * @param value The value
     * @return The type name
     */
    private String getTypeName(Object value) {
        if (value == null) return "null";
        if (value instanceof Integer) return "NUMBER";
        if (value instanceof Double) return "DECIMAL";
        if (value instanceof String) return "MESSAGE";
        if (value instanceof Boolean) return "BINARY";
        return value.getClass().getSimpleName();
    }

    /**
     * Handles RETURN statements by parsing the return value and setting it
     * @param line The RETURN statement line
     * @param lineNumber The line number for error reporting
     */
    private void handleReturn(String line, int lineNumber) {
        // Extract the return value from "RETURN value;"
        String returnExpr = line.substring(7).trim(); // Remove "RETURN "
        if (returnExpr.endsWith(";")) {
            returnExpr = returnExpr.substring(0, returnExpr.length() - 1).trim();
        }
        
        if (returnExpr.isEmpty()) {
            this.returnValue = null;
        } else {
            try {
                // Try to evaluate the return expression
                this.returnValue = evaluateExpression(returnExpr, this.variables, lineNumber);
            } catch (Exception e) {
                // If evaluation fails, store as string
                this.returnValue = returnExpr;
            }
        }
    }
}

/**
 * HumanLang - Main class for the HumanLang interpreter
 * 
 * This is the entry point for the HumanLang programming language interpreter.
 * It handles file reading, lexical analysis, and code execution.
 * 
 * Usage: java HumanLang [filename]
 * If no filename is provided, defaults to "src/humanlang/sample-code.txt"
 */
public class HumanLang {
    /**
     * Main entry point for the HumanLang interpreter
     * @param args Command line arguments - first argument is the source file path
     */
    public static void main(String[] args) {
        // Determine source file path from command line arguments
        String filePath = "C:\\Users\\acer\\Downloads\\sample_code.txt"; // Default file
        if (args.length > 0) {
            filePath = args[0]; // Use provided file path
        }
        
        StringBuilder codeBuilder = new StringBuilder();

        // Read the HumanLang source file
        try (FileReader fr = new FileReader(filePath);
             BufferedReader br = new BufferedReader(fr)) {

            String line;
            while ((line = br.readLine()) != null) {
                codeBuilder.append(line).append("\n");
            }

        } catch (IOException e) {
            System.err.println("Error: Could not read file '" + filePath + "': " + e.getMessage());
            System.exit(1);
        }

        // Get the complete source code
        String code = codeBuilder.toString();

        // Validate that file contains code
        if (code.trim().isEmpty()) {
            System.err.println("Error: File is empty or contains no valid code.");
            System.exit(1);
        }

        // First, remove comments from the entire code to handle multiline comments
        LexicalAnalyzer commentRemover = new LexicalAnalyzer(code, 0);
        String codeWithoutComments = commentRemover.getCodeWithoutComments();
        
        // Perform lexical analysis on the source code line by line
        String[] lines = codeWithoutComments.split("\n");
        boolean allValid = true;
        
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i].trim();
            if (!line.isEmpty()) {
                LexicalAnalyzer analyzer = new LexicalAnalyzer(line, i + 1);
                if (!analyzer.analyze()) {
                    allValid = false;
                }
            }
        }
        
        if (!allValid) {
            System.exit(1);
        }

        // Validate semicolon requirements on code with comments removed
        LexicalAnalyzer mainAnalyzer = new LexicalAnalyzer(codeWithoutComments);
        boolean semicolonsValid = mainAnalyzer.validateSemicolons(mainAnalyzer.code);
        if (!semicolonsValid) {
            System.exit(1);
        }
        
        // Pre-parse to find all function definitions
        try {
            Interpreter preParser = new Interpreter();
            preParser.parseFunctionDefinitions(codeWithoutComments.split("\n"));
        } catch (Exception e) {
            System.exit(1);
        }
        
        // Then perform token analysis
        boolean isValid = mainAnalyzer.analyze();

        // Execute the code if lexical analysis passes
        if (isValid) {
            try {
            Interpreter interpreter = new Interpreter();
                interpreter.executeCode(codeWithoutComments);
            } catch (Exception e) {
                System.err.println("Error during execution: " + e.getMessage());
                System.exit(1);
            }
        } else {
            System.out.println("Syntax error detected. Execution aborted.");
            System.exit(1);
        }
    }
    
}
